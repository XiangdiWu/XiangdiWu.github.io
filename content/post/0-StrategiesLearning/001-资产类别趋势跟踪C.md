---
layout:      post
title:       "Strategy 1：资产类别趋势跟踪C"
subtitle:    "Strategy Learning 1: Asset Class Trend Tracking 3"
description: "本文拆解了一个名为资产类别趋势跟踪策略的代码，同时介绍了这个动量策略的基本原理、回测框架、以及潜在的问题和改进建议。"
author:      "XiangdiWu"
date:        2024-09-25
image:       "/img/background.webp"

categories:  ["Quant" ]
tags:
    - quant
    - strategy

draft:       true
params:
    mermaid:	true
    math:		true
---

这份代码是上一版的“**增强调试版**”：  
- 把均线周期从 300 缩短到 **40**（更敏感）；  
- 增加了 **`notify_order`** 和 **`notify_trade`**，**打印每一笔成交明细与盈亏**；  
- 其余框架（绩效分析器、ETF池、全仓买卖）保持不变。  

---

## 策略参数与指标构建

```python
class MomentumStrategy(bt.Strategy):
    params = (('ma_period', 40),)
```

- 周期改成 **40 日均线**，信号更频繁，**换手更高**。

```python
    def __init__(self):
        self.sma = {data: bt.indicators.SimpleMovingAverage(
                    data.close, period=self.params.ma_period) for data in self.datas}
        self.order = None
```

- 与之前完全相同，**每个ETF独立计算40日SMA**。

---

## 订单生命周期日志：`notify_order`

```python
    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            return
```

- **提交/接受**状态不做任何操作，只是中间状态。

```python
        if order.status in [order.Completed]:
            if order.isbuy():
                print(f"买入: {order.data._name}, 数量: {order.size}, "
                      f"价格: {order.executed.price:.3f}, "
                      f"成本: {order.executed.value:.2f}, "
                      f"手续费: {order.executed.comm:.2f}")
            elif order.issell():
                print(f"卖出: {order.data._name}, 数量: {order.size}, "
                      f"价格: {order.executed.price:.3f}, "
                      f"成本: {order.executed.value:.2f}, "
                      f"手续费: {order.executed.comm:.2f}")
            self.bar_executed = len(self)
```

- **成交瞬间**打印买卖方向、品种、数量、价格、成交金额、手续费。  
- `order.executed.comm` 是 **默认手续费模型**下的佣金（本例未设置，为0）。  
- `self.bar_executed` 记录**成交时的K线索引**，可用于后续持仓天数统计。

---

## 交易闭环日志：`notify_trade`

```python
    def notify_trade(self, trade):
        if not trade.isclosed:
            return
        print(f"交易利润, 毛利润: {trade.pnl:.2f}, 净利润: {trade.pnlcomm:.2f}")
```

- **一笔交易 = 一次开仓+一次平仓**；  
- `trade.pnl` **毛利润**（不含佣金）；  
- `trade.pnlcomm` **净利润**（扣除佣金）。  
- 只在**平仓时**触发，方便**逐笔盈亏复盘**。

---

## 交易信号逻辑：`next`

```python
    def next(self):
        if self.order:
            return
        for data in self.datas:
            if self.getposition(data).size == 0:
                if data.close[0] > self.sma[data][0]:
                    self.order = self.buy(data=data)
            else:
                if data.close[0] < self.sma[data][0]:
                    self.order = self.sell(data=data)
```

- 与之前完全一致，**40日均线上穿买入、下穿卖出**。  
- **单例`self.order`** 仍会导致**同一天只能下一单**；若多个ETF同时触发，只能执行第一个。  
→ 改进：把`self.order`换成`self.orders=dict()`，按品种独立控制（见文末）。

---

## 绩效分析器：`PerformanceAnalyzer`

与上一版**完全相同**，不再赘述。  
输出：**年化收益、年化波动、夏普、最大回撤**。

---

## 回测设置与运行

```python
if __name__ == '__main__':
    cerebro = bt.Cerebro()
```

### ETF池（共5只，上交所）

| 代码 | 名称 | 资产类别 |
|------|------|----------|
| 000300.SS | 沪深300ETF | A股大盘 |
| 513500.SS | 纳指ETF | 美股科技 |
| 511010.SS | 10年期国债ETF | 利率债 |
| 512800.SS | 银行ETF | 行业主题 |
| 510170.SS | 大宗商品ETF | 商品 |

```python
    for etf in etfs:
        data = bt.feeds.PandasData(dataname=yf.download(etf, start="2020-01-01", end="2024-01-01"))
        cerebro.adddata(data, name=etf)
```

- **每次运行都会重新下载**，可缓存到本地CSV加速。  
- 区间**2020-01-01至2024-01-01**，共4年。

```python
    cerebro.addstrategy(MomentumStrategy)
    cerebro.broker.set_cash(1_000_000)
    cerebro.addsizer(bt.sizers.AllInSizer)
    #cerebro.broker.setcommission(commission=0.00025)
    cerebro.addanalyzer(PerformanceAnalyzer, _name='performance')
```

- **全仓买卖**；  
- 手续费被**注释掉**，目前**0佣金**；  
- 绩效分析器已挂载。

---

## 运行结果打印

```python
    results = cerebro.run()
    strat = results[0]
    performance = strat.analyzers.performance.get_analysis()
```

控制台会**先打印每一笔成交**，最后给出：

```
期初资产: 1000000.00
买入: 000300.SS, 数量: 2441, 价格: 4.095, 成本: 9999.50, 手续费: 0.00
卖出: 000300.SS, 数量: -2441, 价格: 4.155, 成本: 10142.36, 手续费: 0.00
交易利润, 毛利润: 142.86, 净利润: 142.86
...
期末资产: 1xxx xxx.xx
年化收益: xx.xx%
年化波动: xx.xx%
最大回撤: xx.xx%
夏普比: x.xx
```

---

## 优点总结

1. **调试级日志**：每笔成交、手续费、盈亏一目了然。  
2. **40日均线**：信号更频繁，适合**中短期趋势跟踪**。  
3. **绩效指标完整**：年化、回撤、夏普全都有。  
4. **A股ETF池**：人民币账户可实盘。

---

## 主要风险与改进点

| 问题 | 现象 | 改进方案 |
|------|------|----------|
| **单例order** | 同一天只能下一单 | `self.orders=dict()`按品种管理 |
| **全仓** | 回撤大 | `PercentSizer(20)`每品种最多20% |
| **0佣金** | 高估收益 | `setcommission(commission=0.0003)` |
| **滑点忽略** | 连续信号全部成交 | `set_slippage_perc(0.0005)` |
| **40日均线敏感** | 震荡市反复止损 | 加**过滤器**（如ATR、ADX>25） |
| **数据重复下载** | 运行慢 | 缓存到CSV：`data.to_csv('xxx.csv')` |

---

## 示例：多order管理+仓位控制（核心片段）

```python
class MomentumStrategy(bt.Strategy):
    def __init__(self):
        self.sma = {d: bt.ind.SMA(d.close, period=40) for d in self.datas}
        self.orders = {}          # data -> order

    def next(self):
        for d in self.datas:
            if self.getposition(d).size == 0:
                if d.close[0] > self.sma[d][0]:
                    if d not in self.orders:
                        self.orders[d] = self.buy(data=d)
            else:
                if d.close[0] < self.sma[d][0]:
                    if d not in self.orders:
                        self.orders[d] = self.sell(data=d)

    def notify_order(self, order):
        if order.status in [order.Completed, order.Canceled, order.Rejected]:
            self.orders.pop(order.data, None)   # 清理
```

---

## 结语

这段代码已经**足够调试级**，你可以：

1. 打开控制台，**看到每一笔成交**；  
2. 把**手续费、滑点、仓位**加上，再跑一次，看夏普、回撤变化；  
3. 用**参数扫描**（20~200日均线）找稳健区间；  
4. 用**Walk-Forward**防止过拟合；  
5. 用**官方复权净值**再验证一次。

如果你想，我可以给你一份**带缓存、多order、仓位控制、参数优化的完整脚本**，直接跑实盘模拟。

## 完整代码

```python
import backtrader as bt
import yfinance as yf
import numpy as np

class MomentumStrategy(bt.Strategy):
    params = (
        ('ma_period', 40),
    )

    def __init__(self):
        self.sma = {data: bt.indicators.SimpleMovingAverage(data.close, period=self.params.ma_period) for data in self.datas}
        self.order = None

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            return  # 订单提交或接受时不执行任何操作

        if order.status in [order.Completed]:
            if order.isbuy():
                print(f"买入: {order.data._name}, 数量: {order.size}, 价格: {order.executed.price}, 成本: {order.executed.value}, 手续费: {order.executed.comm}")
            elif order.issell():
                print(f"卖出: {order.data._name}, 数量: {order.size}, 价格: {order.executed.price}, 成本: {order.executed.value}, 手续费: {order.executed.comm}")
            self.bar_executed = len(self)

        self.order = None

    def notify_trade(self, trade):
        if not trade.isclosed:
            return

        print(f"交易利润, 毛利润: {trade.pnl}, 净利润: {trade.pnlcomm}")

    def next(self):
        if self.order:
            return
        
        for data in self.datas:
            if self.getposition(data).size == 0:
                if data.close[0] > self.sma[data][0]:
                    self.order = self.buy(data=data)
            else:
                if data.close[0] < self.sma[data][0]:
                    self.order = self.sell(data=data)

class PerformanceAnalyzer(bt.Analyzer):
    def __init__(self):
        self.rets = []

    def next(self):
        self.rets.append(self.strategy.broker.getvalue())

    def get_analysis(self):
        returns = np.diff(self.rets) / self.rets[:-1]
        annual_return = np.mean(returns) * 252
        annual_volatility = np.std(returns) * np.sqrt(252)
        sharpe_ratio = annual_return / annual_volatility

        # 最大回撤计算
        cum_returns = np.maximum.accumulate(self.rets)
        drawdowns = (cum_returns - self.rets) / cum_returns
        max_drawdown = np.max(drawdowns)

        return {
            'portfolio_value': self.rets[-1],
            'annual_return': annual_return,
            'annual_volatility': annual_volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown
        }

if __name__ == '__main__':
    cerebro = bt.Cerebro()

    etfs = ['000300.SS', '513500.SS', '511010.SS', '512800.SS', '510170.SS']
    for etf in etfs:
        data = bt.feeds.PandasData(dataname=yf.download(etf, start="2020-01-01", end="2024-01-01"))
        cerebro.adddata(data, name=etf)

    cerebro.addstrategy(MomentumStrategy)
    
    cerebro.broker.set_cash(1000000)
    cerebro.addsizer(bt.sizers.AllInSizer)
    #cerebro.broker.setcommission(commission=0.00025)
    cerebro.addanalyzer(PerformanceAnalyzer, _name='performance')

    print('期初资产: %.2f' % cerebro.broker.getvalue())
    results = cerebro.run()
    strat = results[0]

    print('期末资产: %.2f' % cerebro.broker.getvalue())

    performance = strat.analyzers.performance.get_analysis()
    print('年化收益: {:.2f}%'.format(performance['annual_return'] * 100))
    print('年化波动: {:.2f}%'.format(performance['annual_volatility'] * 100))
    print('最大回撤: {:.2f}%'.format(performance['max_drawdown'] * 100))
    print('夏普比: {:.2f}'.format(performance['sharpe_ratio']))

    cerebro.plot()

```
