---
layout:      post
title:       "Strategy 2：动量资产配置策略"
subtitle:    "Strategy Learning 2: Momentum Asset Allocation Strategy"
description: "本文介绍了动量资产配置策略的基本原理和实现。"
author:      "XiangdiWu"
date:        2024-09-26
image:       "/img/background.webp"

categories:  ["Quant" ]
tags:
    - quant
    - strategy

draft:       true
params:
    mermaid:	true
    math:		true
---
策略来源：QuantGirl

## 先放绩效指标
- 回测时间： 最近4年
- 期初资产：1,000,000 美元
- 期末资产：1076180.90 美元
- 年化收益：2.17%
- 年化波动：9.72%
- 最大回撤：18.71%
- 夏普比：0.22

## 策略概述
动量资产配置策略结合了趋势跟踪和相对强度技术，通过轮换不同资产类别来实现最佳投资回报。这种策略已被用作投资策略超过一个世纪，是最广泛讨论和研究的投资策略之一。

## 关键要点
- 动量策略利用趋势跟踪和相对强度技术
- 轮换动量交易系统通过比较所有资产类别的表现，挑选表现最佳的资产
- 投资组合每月重新平衡，持有表现最佳的资产
- 该策略表现强劲，经过了多种稳定性测试

## 交易资产
- 股票
- 债券
- 大宗商品
- 房地产投资信托基金（REITs）
- ETFs: SPY（美股）、EFA（外国股票）、BND（债券）、VNQ（REITs）、GSG（大宗商品）

## 交易策略
1. 选择表现最强的三个12个月动量的ETF，按等权重纳入投资组合
2. 每月持有并重新平衡投资组合

## 交易信号
- 轮换动量系统比较所有资产类别的表现
- 挑选表现最佳的资产类别进行投资

## 论文出处
Mebane Faber: Relative Strength Strategies for Investing

## 代码实现
```python

import backtrader as bt
import yfinance as yf
import numpy as np
import pandas as pd

class MomentumStrategy(bt.Strategy):
    params = (
        ('lookback_period', 252),  # 12个月的交易日
        ('hold_period', 21),       # 持有期为一个月
    )

    def log(self, txt):
        ''' Logging function '''
        print(f'{self.datas[0].datetime.date(0)}: {txt}')

    def __init__(self):
        self.order = None
        self.start_cash = self.broker.getvalue()

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            return  # 订单提交或接受时不执行任何操作

        if order.status in [order.Completed]:
            if order.isbuy():
                self.log("BUY EXECUTED, Price: %.2f, Size: %.2f" % (order.executed.price, order.executed.size))
            elif order.issell():
                self.log("SELL EXECUTED, Price: %.2f, Size: %.2f" % (order.executed.price, order.executed.size))

        self.order = None

    def next(self):
        # 每月开始时再平衡
        if len(self) % self.params.hold_period == 0:
            self.rebalance_portfolio()
        else:
            return

    def rebalance_portfolio(self):
        self.log("Rebalancing Portfolio")
        # 清仓
        for data in self.datas:
            if self.getposition(data).size:
                self.sell(data=data)
        
        # 计算应该买入的ETF列表
        momentum_scores = {data: data.close[0] / data.close[-self.params.lookback_period] for data in self.datas}
        sorted_momentum = sorted(momentum_scores.items(), key=lambda x: x[1], reverse=True)
        etf_to_buy = [x[0] for x in sorted_momentum[:3]]  # 选择动量最高的3个ETF

        if etf_to_buy:
            # 平分资金
            weight = self.broker.getvalue() / len(etf_to_buy)
            for data in etf_to_buy:
                self.order_target_value(data=data, target=weight)
        else:
            self.log("No ETFs meet criteria, holding cash")

class PerformanceAnalyzer(bt.Analyzer):
    def __init__(self):
        self.rets = []

    def next(self):
        self.rets.append(self.strategy.broker.getvalue())

    def get_analysis(self):
        returns = np.diff(self.rets) / self.rets[:-1]
        annual_return = np.mean(returns) * 252
        annual_volatility = np.std(returns) * np.sqrt(252)
        sharpe_ratio = annual_return / annual_volatility

        # 最大回撤计算
        cum_returns = np.maximum.accumulate(self.rets)
        drawdowns = (cum_returns - self.rets) / cum_returns
        max_drawdown = np.max(drawdowns)

        return {
            'portfolio_value': self.rets[-1],
            'annual_return': annual_return,
            'annual_volatility': annual_volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown
        }

if __name__ == '__main__':
    cerebro = bt.Cerebro()

    etfs = ['SPY', 'EFA', 'BND', 'VNQ', 'GSG']
    for etf in etfs:
        data = bt.feeds.PandasData(dataname=yf.download(etf, start="2020-01-01", end="2024-05-01"))
        cerebro.adddata(data, name=etf)

    cerebro.addstrategy(MomentumStrategy)
    
    cerebro.broker.set_cash(1000000)
    cerebro.addsizer(bt.sizers.AllInSizer)

    cerebro.addanalyzer(PerformanceAnalyzer, _name='performance')

    print('期初资产: %.2f' % cerebro.broker.getvalue())
    results = cerebro.run()
    strat = results[0]

    print('期末资产: %.2f' % cerebro.broker.getvalue())

    performance = strat.analyzers.performance.get_analysis()
    print('年化收益: {:.2f}%'.format(performance['annual_return'] * 100))
    print('年化波动: {:.2f}%'.format(performance['annual_volatility'] * 100))
    print('最大回撤: {:.2f}%'.format(performance['max_drawdown'] * 100))
    print('夏普比: {:.2f}'.format(performance['sharpe_ratio']))

    cerebro.plot()

```