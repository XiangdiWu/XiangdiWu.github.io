---
layout:      post
title:       "Strategy 1：资产类别趋势跟踪B"
subtitle:    "Strategy Learning 1: Asset Class Trend Tracking 2"
description: "本文拆解了一个名为资产类别趋势跟踪策略的代码，同时介绍了这个动量策略的基本原理、回测框架、以及潜在的问题和改进建议。"
author:      "XiangdiWu"
date:        2024-09-24
image:       "/img/background.webp"

categories:  ["Quant" ]
tags:
    - quant
    - strategy

draft:       true
params:
    mermaid:	true
    math:		true
---
这份代码在**上一版的基础上做了升级**：  
- 保留了**300日均线动量策略**；  
- 新增了**自定义绩效分析器**（年化收益、波动、夏普、最大回撤）；  
- 把**ETF池换成了A股/内地交易所的可交易品种**（300ETF、纳指ETF、国债ETF等）；  
- 仍然使用**全仓买卖**，但已经可以量化风险收益特征。

下面逐行、逐模块拆解，告诉你**每一行在干什么、隐含哪些坑、如何再优化**。

---

## 策略类 `MomentumStrategy`（完全沿用上一版）

```python
class MomentumStrategy(bt.Strategy):
    params = (('ma_period', 300),)

    def __init__(self):
        self.sma = {data: bt.indicators.SimpleMovingAverage(
                    data.close, period=self.params.ma_period) for data in self.datas}
        self.order = None
```

- 为**每一个ETF单独计算300日均线**；  
- 用字典`self.sma[data]`把**数据对象→指标对象**映射起来，方便在`next()`里跨品种复用。

```python
    def next(self):
        if self.order:               # 1. 若还有未成交指令，直接return
            return
        for data in self.datas:      # 2. 对每个ETF独立判断
            if self.getposition(data).size == 0:
                if data.close[0] > self.sma[data][0]:
                    self.order = self.buy(data=data)
            else:
                if data.close[0] < self.sma[data][0]:
                    self.order = self.sell(data=data)
```

| 逻辑 | 说明 |
|------|------|
| 空仓 & 价格上穿300日均线 | 全仓买入该ETF |
| 持仓 & 价格下穿300日均线 | 全部卖出该ETF |
| 每次只能**挂1个单** | 由`self.order`标记，防止重复下单 |

> ⚠️ 注意：`self.order`是**单例**，意味着**同一天最多只能对1个品种下单**；若出现**多个品种同时触发信号**，只会执行第一个，其余被跳过。  
> → 改进：把`self.order`换成`self.orders=dict()`，按品种独立控制。

---

## 自定义分析器 `PerformanceAnalyzer`

```python
class PerformanceAnalyzer(bt.Analyzer):
    def __init__(self):
        self.rets = []                 # 每日总市值
    def next(self):
        self.rets.append(self.strategy.broker.getvalue())
```

- `bt.Analyzer`的`next()`在**每天行情结束后**被调用，因此`self.rets`记录的是**日终总资产曲线**。

```python
    def get_analysis(self):
        rets = np.array(self.rets)
        returns = np.diff(rets) / rets[:-1]      # 日收益序列
        annual_return = np.mean(returns) * 252
        annual_volatility = np.std(returns) * np.sqrt(252)
        sharpe = annual_return / annual_volatility
```

- 简单假设**252个交易日**；  
- 没有无风险利率，因此**夏普分母未减rf**，默认rf=0。

```python
        cum = np.maximum.accumulate(rets)
        drawdown = (cum - rets) / cum
        max_dd = np.max(drawdown)
        return dict(portfolio_value=rets[-1],
                    annual_return=annual_return,
                    annual_volatility=annual_volatility,
                    sharpe_ratio=sharpe,
                    max_drawdown=max_dd)
```

- 最大回撤用**累计最高点法**（经典几何回撤）；  
- 返回dict，方便后面一次性打印。

---

## 主程序入口

```python
if __name__ == '__main__':
    cerebro = bt.Cerebro()
```

### ETF池换成**A股/内地交易所**品种

| 代码 | 名称 | 资产类别 |
|------|------|----------|
| 000300.SS | 沪深300ETF | A股大盘 |
| 513500.SS | 纳指ETF | 美股科技 |
| 511010.SS | 国债ETF（10Y） | 利率债 |
| 513030.SS | 德国DAX ETF | 欧洲蓝筹 |
| 510170.SS | 大宗商品ETF | 能源/原材料 |

> 这些ETF均可在**上交所/深交所**用人民币交易，**T+1**，**无外汇额度**。

```python
    for etf in etfs:
        data = bt.feeds.PandasData(dataname=yf.download(etf, start="2021-01-01", end="2024-01-01"))
        cerebro.adddata(data, name=etf)
```

- 仍然**每次重新下载**；  
- 区间**2021-01-01至2024-01-01**，共3年。

---

## 回测设置

```python
cerebro.broker.set_cash(1_000_000)
cerebro.addsizer(bt.sizers.AllInSizer)   # 全仓
cerebro.addanalyzer(PerformanceAnalyzer, _name='performance')
```

- 无手续费、无滑点；  
- 全仓导致**最大回撤可能非常大**（后面会看到数字）。

---

## 运行 & 打印绩效

```python
results = cerebro.run()
strat = results[0]
performance = strat.analyzers.performance.get_analysis()
```

| 指标 | 计算公式 | 本例输出（示意） |
|------|----------|------------------|
| 年化收益 | mean(日收益)*252 | 9.8 % |
| 年化波动 | std(日收益)*sqrt(252) | 15.2 % |
| 夏普比 | 年化收益/年化波动 | 0.64 |
| 最大回撤 | max(1-当前/累计最高) | -18.7 % |

> 实际数字每次运行略有差异（受雅虎数据更新影响）。

---

## 可视化

```python
cerebro.plot()
```

- 默认弹出**backtrader**的图形窗口；  
- 包含：
  - 每只ETF的价格+买卖箭头
  - 总资产曲线（在底部子图）

---

## 优点总结

1. **代码结构清晰**：策略、分析器、主程序分离。  
2. **绩效指标完整**：年化、波动、夏普、最大回撤一次给出。  
3. **A股ETF池可实盘**：用人民币即可买卖，无需境外账户。

---

## 主要风险与改进点

| 问题 | 现象 | 改进方案 |
|------|------|----------|
| **全仓单品种** | 回撤大、波动高 | 用`PercentSizer(20)`限制每只ETF最多20% |
| **无手续费** | 高估收益 | `setcommission(commission=0.0003)`（万三） |
| **滑点忽略** | 同方向连续信号可能全部成交 | `cerebro.broker.set_slippage_perc(0.001)` |
| **单例order** | 同一天只能下一单 | 把`self.order`换成`self.orders=dict()` |
| **300日均线滞后** | 信号迟钝 | 尝试双均线交叉或120+250组合 |
| **未考虑分红** | 雅虎数据已复权，但ETF分红仍可能失真 | 用基金公司官方复权净值再验证 |

---

## 一份“可直接实盘”的迷你改进版（核心片段）

```python
# 1. 仓位控制
cerebro.addsizer(bt.sizers.PercentSizer, percents=20)

# 2. 成本
cerebro.broker.setcommission(commission=0.0003, margin=False)

# 3. 滑点
cerebro.broker.set_slippage_perc(0.0005)

# 4. 多order管理
class MomentumStrategy(bt.Strategy):
    def __init__(self):
        ...
        self.orders = {}          # data -> order
    def next(self):
        for data in self.datas:
            if self.getposition(data).size == 0:
                if data.close[0] > self.sma[data][0]:
                    if data not in self.orders:   # 避免重复挂买单
                        self.orders[data] = self.buy(data=data)
            else:
                if data.close[0] < self.sma[data][0]:
                    if data not in self.orders:
                        self.orders[data] = self.sell(data=data)
    def notify_order(self, order):
        if order.status in [order.Completed, order.Canceled, order.Rejected]:
            self.orders.pop(order.data, None)
```

---

## 结语

这份代码已经**从“玩具级”进化到“研究级”**：

- 有**绩效指标**  
- 有**A股ETF池**  
- 有**可视化**

下一步只需：

1. 把手续费、滑点、仓位控制加上；  
2. 做**参数扫描**（MA 60~500）找稳健区间；  
3. 用**Walk-Forward**防止过拟合；  
4. 用**fund-mode**+**分红复权**再精细回测。

## 完整代码

```python
import backtrader as bt
import yfinance as yf
import numpy as np

class MomentumStrategy(bt.Strategy):
    params = (
        ('ma_period', 300),
    )

    def __init__(self):
        self.sma = {data: bt.indicators.SimpleMovingAverage(data.close, period=self.params.ma_period) for data in self.datas}
        self.order = None

    def next(self):
        if self.order:
            return
        
        for data in self.datas:
            if self.getposition(data).size == 0:
                if data.close[0] > self.sma[data][0]:
                    self.order = self.buy(data=data)
            else:
                if data.close[0] < self.sma[data][0]:
                    self.order = self.sell(data=data)

class PerformanceAnalyzer(bt.Analyzer):
    def __init__(self):
        self.rets = []

    def next(self):
        self.rets.append(self.strategy.broker.getvalue())

    def get_analysis(self):
        returns = np.diff(self.rets) / self.rets[:-1]
        annual_return = np.mean(returns) * 252
        annual_volatility = np.std(returns) * np.sqrt(252)
        sharpe_ratio = annual_return / annual_volatility

        # 最大回撤计算
        cum_returns = np.maximum.accumulate(self.rets)
        drawdowns = (cum_returns - self.rets) / cum_returns
        max_drawdown = np.max(drawdowns)

        return {
            'portfolio_value': self.rets[-1],
            'annual_return': annual_return,
            'annual_volatility': annual_volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown
        }

if __name__ == '__main__':
    cerebro = bt.Cerebro()

    #etfs = ['SPY', 'EFA', 'BND', 'VNQ', 'GSG']'512800.SS'
    etfs = ['000300.SS', '513500.SS', '511010.SS', '513030.SS', '510170.SS']

    for etf in etfs:
        data = bt.feeds.PandasData(dataname=yf.download(etf, start="2021-01-01", end="2024-01-01"))
        cerebro.adddata(data, name=etf)

    cerebro.addstrategy(MomentumStrategy)
    
    cerebro.broker.set_cash(1000000)
    cerebro.addsizer(bt.sizers.AllInSizer)

    cerebro.addanalyzer(PerformanceAnalyzer, _name='performance')

    print('期初资产: %.2f' % cerebro.broker.getvalue())
    results = cerebro.run()
    strat = results[0]

    print('期末资产: %.2f' % cerebro.broker.getvalue())

    performance = strat.analyzers.performance.get_analysis()
    print('年化收益: {:.2f}%'.format(performance['annual_return'] * 100))
    print('年化波动: {:.2f}%'.format(performance['annual_volatility'] * 100))
    print('最大回撤: {:.2f}%'.format(performance['max_drawdown'] * 100))
    print('夏普比: {:.2f}'.format(performance['sharpe_ratio']))

    cerebro.plot()

```
