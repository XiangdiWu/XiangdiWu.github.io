<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="Xiangdi Blog"><meta property="og:type" content="article"><meta property="og:image" con ’tent=https://images.pexels.com/photos/220301/pexels-photo-220301.jpeg><meta property="twitter:image" content="https://images.pexels.com/photos/220301/pexels-photo-220301.jpeg"><meta name=title content="深度学习：注意力机制与外部记忆"><meta property="og:title" content="深度学习：注意力机制与外部记忆"><meta property="twitter:title" content="深度学习：注意力机制与外部记忆"><meta name=description content="本文主要介绍了注意力机制和外部记忆的相关内容，包括注意力机制的原理、注意力机制的应用、注意力机制的变体、注意力机制的应用。"><meta property="og:description" content="本文主要介绍了注意力机制和外部记忆的相关内容，包括注意力机制的原理、注意力机制的应用、注意力机制的变体、注意力机制的应用。"><meta property="twitter:description" content="本文主要介绍了注意力机制和外部记忆的相关内容，包括注意力机制的原理、注意力机制的应用、注意力机制的变体、注意力机制的应用。"><meta property="twitter:card" content="summary"><meta property="og:url" content="https://xiangdiwu.github.io/post/4-dl/dl8-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%A4%96%E9%83%A8%E8%AE%B0%E5%BF%86/"><meta name=keyword content="吴湘菂, WuXiangdi, XiangdiWu, 吴湘菂的网络日志, 吴湘菂的博客, Xiangdi Blog, 博客, 个人网站, Quant, 量化投资, 金融, 投资, 理财, 股票, 期货, 基金, 期权, 外汇, 比特币"><link rel="shortcut icon" href=/img/favicon.ico><title>深度学习：注意力机制与外部记忆-吴湘菂的博客 | Xiangdi Blog</title><link rel=canonical href=/post/4-dl/dl8-%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%A4%96%E9%83%A8%E8%AE%B0%E5%BF%86/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.min.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/hux-blog.min.js></script><script src=/js/lazysizes.min.js></script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-R757MDJ6Y6"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-R757MDJ6Y6")}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"\\[",right:"\\]",display:!0},{left:"$$",right:"$$",display:!0},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})})</script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type=text/javascript></script><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Xiangdi Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/quant/>quant</a></li><li><a href=/categories/reading/>reading</a></li><li><a href=/categories/tech/>tech</a></li><li><a href=/archive//>ARCHIVE</a></li><li><a href=/vibe//>Vibe</a></li><li><a href=/travel//>TRAVEL</a></li><li><a href=/about//>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(https://images.pexels.com/photos/220301/pexels-photo-220301.jpeg)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/quant title=Quant>Quant
</a><a class=tag href=/tags/model title=Model>Model
</a><a class=tag href=/tags/deep-learning title="Deep Learning">Deep Learning</a></div><h1>深度学习：注意力机制与外部记忆</h1><h2 class=subheading>Attention mechanism and external memory</h2><span class=meta>Posted by
XiangdiWu
on
Sunday, October 18, 2020</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><p>根据通用近似定理，前馈网络和循环网络都有很强的能力。但由于优化算法和计算能力的限制，在实践中很难达到通用近似的能力。特别是在处理复杂任务时，比如需要处理大量的输入信息或者复杂的计算流程时，目前计算机的计算能力依然是限制神经网络发展的瓶颈。</p><p>为了减少计算复杂度，通过部分借鉴生物神经网络的一些机制，我们引入了局部连接、权重共享以及汇聚操作来简化神经网络结构。虽然这些机制可以有效缓解模型的复杂度和表达能力之间的矛盾，但是我们依然希望<strong>在不过度增加模型复杂度(主要是模型参数)的情况下来提高模型的表达能力</strong>。</p><p>神经网络中可以存储的信息量称为<strong>网络容量(network capacity)</strong>。一般来讲，利用一组神经元来存储信息时，其存储容量和神经元的数量以及网络的复杂度成正比。如果要存储越多的信息，神经元数量就要越多或者网络要越复杂，进而导致神经网络的参数成倍地增加。</p><p>人脑的生物神经网络同样存在网络容量问题，工作记忆大概只有几秒钟的时间，类似于循环神经网络中的隐状态。而人脑每个时刻接收的外界输入信息非常多，包括来自于视觉、听觉、触觉的各种各样的信息。单就视觉来说，眼睛每秒钟都会发送千万比特的信息给视觉神经系统。人脑在有限的资源下，并不能同时处理这些过载的输入信息。大脑神经系统有两个重要机制可以解决信息过载问题：<strong>注意力(attention)</strong> 和<strong>记忆(memory)</strong> 机制。注意力机制通过自上而下的信息选择机制来过滤掉大量的无关信息；记忆机制引入额外外部记忆，优化神经网络的记忆结构来提高神经网络存储信息的容量。</p><h1 id=注意力>注意力</h1><h2 id=认知神经学中的注意力>认知神经学中的注意力</h2><p>注意力是一种人类不可或缺的复杂认知功能，指人可以在关注一些信息的同时忽略另一些信息的选择能力。在日常生活中，我们通过视觉、听觉、触觉等方式接收大量的感觉输入。但是人脑还能在这些外界的信息轰炸中有条不紊地工作，是因为人脑可以有意或无意地从这些大量输入信息中<strong>选择小部分的有用信息来重点处理</strong>，并忽略其他信息。这种能力就叫做注意力。注意力可以作用在外部的刺激(听觉、视觉、味觉等)，也可以作用在内部的意识(思考、回忆等)。注意力一般分为两种：</p><p>一种是<strong>自上而下的有意识的注意力</strong>，称为<strong>聚焦式注意力(focus attention)</strong>。聚焦式注意力是指有预定目的、依赖任务的，主动有意识地聚焦于某一对象的注意力。</p><p>另一种是<strong>自下而上的无意识的注意力</strong>，称为<strong>基于显著性的注意力(saliency based attention)</strong>。基于显著性的注意力是由外界刺激驱动的注意，不需要主动干预，也和任务无关。<strong>如果一个对象的刺激信息不同于其周围信息，一种无意识的“赢者通吃”(winner-take-all)或者门控(gating)机制就可以把注意力转向这个对象</strong>。不管这些注意力是有意还是无意，大部分的人脑活动都需要依赖注意力，比如记忆信息、阅读或思考等。</p><p>一个和注意力有关的例子是<strong>鸡尾酒会效应</strong>。当一个人在吵闹的鸡尾酒会上和朋友聊天时，尽管周围噪音干扰很多，他还是可以听到朋友的谈话内容，而<strong>忽略其他人的声音(聚焦式注意力)</strong>。同时，如果未注意到的背景声中有重要的词(比如他的名字)，<strong>他会马上注意到(显著性注意力)</strong>。</p><p>聚焦式注意力一般会随着环境、情景或任务的不同而选择不同的信息。比如当要从人群中寻找某个人时，我们会专注于每个人的<strong>脸部</strong>；而当要统计人群的人数时，我们只需要专注于每个人的<strong>轮廓</strong>。</p><h2 id=人工神经网络中的注意力>人工神经网络中的注意力</h2><p>用$X = [\boldsymbol x_1, \cdots, \boldsymbol x_N]$表示$N$组输入信息，其中每个向量$\boldsymbol x_i$都表示一组输入信息。为了节省计算资源，不需要将所有信息都输入到神经网络，只需要从$X$中选择一些和任务相关的信息。<strong>注意力机制的计算可以分为两步：一是在所有输入信息上计算注意力分布，二是根据注意力分布来计算输入信息的加权平均</strong>。</p><p>(1) 注意力分布</p><p>为了从$N$个输入向量$X = [\boldsymbol x_1, \cdots, \boldsymbol x_N]$中选择出和某个特定任务相关的信息，我们需要引入一个<strong>和任务相关的表示</strong>，称为<strong>查询向量(query vector)</strong>，并通过一个<strong>打分函数</strong>来计算<strong>每个输入向量和查询向量之间的相关性</strong>。</p><p>给定一个和任务相关的查询$\boldsymbol q$，使用注意力变量$z \in [1,N]$来表示被选择信息的索引位置，即$z=i$表示选择了第$i$个输入向量。为了方便计算，我们采用一种 <strong>“软性”的信息选择机制</strong> 。首先计算在给定$\boldsymbol q$和$X$下，选择第$i$个输入向量的概率$\alpha_i$：</p>$$
\begin{aligned}
\alpha_{i} &=p(z=i | X, \boldsymbol{q}) \\
&=\operatorname{softmax}\left(s\left(\boldsymbol{x}_{i}, \boldsymbol{q}\right)\right) \\
&=\frac{\exp \left(s\left(\boldsymbol{x}_{i}, \boldsymbol{q}\right)\right)}{\sum_{j=1}^{N} \exp \left(s\left(\boldsymbol{x}_{j}, \boldsymbol{q}\right)\right)}
\end{aligned}
$$<p>其中$\alpha_i$称为<strong>注意力分布(attention distribution)</strong>，$s(\boldsymbol x_i,\boldsymbol q)$为注意力打分函数，可以使用以下几种方式来计算：</p><p>加性模型：$s(\boldsymbol{x}_{i}, \boldsymbol{q})=\boldsymbol{v}^{\mathrm{T}} \tanh (W \boldsymbol{x}_{i}+U \boldsymbol{q})$；</p><p>点积模型：$s\left(\boldsymbol{x}_{i}, \boldsymbol{q}\right)=\boldsymbol{x}_{i}^{\mathrm{T}} \boldsymbol{q}$；</p><p>缩放点积模型：$s(\boldsymbol{x}_{i}, \boldsymbol{q})=\frac{\boldsymbol{x}_{i}^{\mathrm{T}} \boldsymbol{q}}{\sqrt{d}}$；</p><p>双线性模型：$s(\boldsymbol{x}_{i}, \boldsymbol{q})=\boldsymbol{x}_{i}^{\mathrm{T}} W \boldsymbol{q}$；</p><p>其中，$W,U,\boldsymbol v$为可学习的参数，$d$为输入向量的维度。</p><p>(2) 加权平均</p><p>注意力分布$\alpha_i$可以解释为在给定任务相关的查询$\boldsymbol q$时，第$i$个输入向量受关注的程度。我们采用一种“软性”的信息选择机制对输入信息进行汇总：</p>$$
\begin{aligned}
\operatorname{att}(X, \boldsymbol{q}) &=\sum_{i=1}^{N} \alpha_{i} \boldsymbol{x}_{i} \\
&=\mathbb{E}_{z \sim p(z | X, \boldsymbol{q})}[\boldsymbol{x}_{z}]
\end{aligned}
$$<p>上式称为<strong>软性注意力机制(soft attention mechanism)</strong>，下图给出了软性注意力机制的示例图：</p><div align=center><img src=/Kimages/3/image-20201004205649318.png style=zoom:40%></div><p>人工神经网络中注意力机制的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Attention</span>(tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>layers<span style=color:#ff79c6>.</span>Layer):
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>__init__</span>(<span style=font-style:italic>self</span>, units):
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>super</span>(BahdanauAttention, <span style=font-style:italic>self</span>)<span style=color:#ff79c6>.</span><span style=color:#50fa7b>__init__</span>()
</span></span><span style=display:flex><span>        <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>W1 <span style=color:#ff79c6>=</span> tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>layers<span style=color:#ff79c6>.</span>Dense(units)
</span></span><span style=display:flex><span>        <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>W2 <span style=color:#ff79c6>=</span> tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>layers<span style=color:#ff79c6>.</span>Dense(units)
</span></span><span style=display:flex><span>        <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>V <span style=color:#ff79c6>=</span> tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>layers<span style=color:#ff79c6>.</span>Dense(<span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>call</span>(<span style=font-style:italic>self</span>, query, values):
</span></span><span style=display:flex><span>        <span style=color:#6272a4># query  shape == (batch_size, hidden size)</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># values shape == (batch_size, max_len, hidden size)</span>
</span></span><span style=display:flex><span>        query_with_time_axis <span style=color:#ff79c6>=</span> tf<span style=color:#ff79c6>.</span>expand_dims(query, <span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#6272a4># we are doing this to broadcast addition along the time axis to calculate the score</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># query_with_time_axis shape == (batch_size, 1, hidden size)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># score shape == (batch_size, max_length, 1)</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># we get 1 at the last axis because we are applying score to self.V</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># the shape of the tensor before applying self.V is (batch_size, max_length, units)</span>
</span></span><span style=display:flex><span>        score <span style=color:#ff79c6>=</span> <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>V(tf<span style=color:#ff79c6>.</span>nn<span style=color:#ff79c6>.</span>tanh(<span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>W1(query_with_time_axis) <span style=color:#ff79c6>+</span> <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>W2(values)))
</span></span><span style=display:flex><span>        <span style=color:#6272a4># 这里评分函数score可以换成其他几种实现形式</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># attention_weights shape == (batch_size, max_length, 1)</span>
</span></span><span style=display:flex><span>        attention_weights <span style=color:#ff79c6>=</span> tf<span style=color:#ff79c6>.</span>nn<span style=color:#ff79c6>.</span>softmax(score, axis<span style=color:#ff79c6>=</span><span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4># context_vector shape after sum == (batch_size, hidden_size)</span>
</span></span><span style=display:flex><span>        context_vector <span style=color:#ff79c6>=</span> attention_weights <span style=color:#ff79c6>*</span> values
</span></span><span style=display:flex><span>        context_vector <span style=color:#ff79c6>=</span> tf<span style=color:#ff79c6>.</span>reduce_sum(context_vector, axis<span style=color:#ff79c6>=</span><span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> context_vector, attention_weights
</span></span></code></pre></div><h2 id=注意力机制的变体>注意力机制的变体</h2><h3 id=硬性注意力>硬性注意力</h3><p>软性注意力选择的信息是所有输入向量在注意力分布下的期望，而<strong>硬性注意力只关注某一个输入向量</strong>。硬性注意力有两种实现方式，一种是<strong>选取最高概率</strong>的一个输入向量，另一种方式是在注意力分布上<strong>随机采样</strong>。</p><p>硬性注意力的一个缺点是基于最大采样或随机采样的方式来选择信息，使得最终的损失函数与注意力分布之间的函数关系不可导，因此无法使用反向传播算法进行训练。<strong>为了使用反向传播算法，一般使用软性注意力来代替硬性注意力</strong>。硬性注意力需要通过<strong>强化学习</strong>来进行训练。</p><h3 id=键值对注意力>键值对注意力</h3><p><strong>键值对是输入信息更一般的格式</strong>。用$(K,V)=[(\boldsymbol k_1,\boldsymbol v_1), \cdots, (\boldsymbol k_N, \boldsymbol v_N)]$表示$N$组输入信息，给定任务相关的查询向量$\boldsymbol q$时，注意力函数为：</p>$$
\begin{aligned}
\operatorname{att}((K, V), \boldsymbol{q}) &=\sum_{i=1}^{N} \alpha_{i} \boldsymbol{v}_{i} \\
&=\sum_{i=1}^{N} \frac{\exp (s(\boldsymbol{k}_{i}, \boldsymbol{q}))}{\sum_{j} \exp (s(\boldsymbol{k}_{j}, \boldsymbol{q}))} \boldsymbol{v}_{i}
\end{aligned}
$$<p>当$K=V$时，键值对模式就等价于普通的注意力机制。</p><h3 id=多头注意力>多头注意力</h3><p><strong>多头注意力(multi-head attention)</strong> 是利用多个查询$Q=[\boldsymbol q_1, \cdots, \boldsymbol q_M]$来平行地从输入信息中选取多组信息。每个注意力关注输入信息的不同部分：</p>$$
\operatorname{att}((K, V), Q)=\operatorname{att}((K, V), \boldsymbol{q}_{1}) \oplus \cdots \oplus \operatorname{att}((K, V), \boldsymbol{q}_{M})
$$<p>其中$\oplus$表示为向量的拼接。</p><h3 id=结构化注意力>结构化注意力</h3><p>在之前介绍中，我们假设所有的输入信息是同等重要的，是一种<strong>扁平(flat)结构</strong>，注意力分布实际上是在所有输入信息上的多项分布。但如果输入信息本身具有<strong>层次(hierarchical)结构</strong>，比如文本可以分为词、句子、段落、篇章等不同粒度的层次，我们可以使用<strong>层次化的注意力</strong>来进行更好的信息选择。此外，还可以假设注意力为上下文相关的二项分布，用一种图模型来构建更复杂的结构化注意力分布。</p><h1 id=注意力机制的应用>注意力机制的应用</h1><p>注意力机制可以单独使用，但更多地用作神经网络中的一个组件。</p><h2 id=指针网络>指针网络</h2><p>注意力机制主要是用来做信息筛选，从输入信息中选取相关的信息。注意力机制可以分为两步：一是计算<strong>注意力分布</strong>$\alpha$，二是根据$\alpha$来计算输入信息的<strong>加权平均</strong>。我们可以只利用注意力机制中的第一步，<strong>将注意力分布作为一个软性的指针(pointer)来指出相关信息的位置</strong>。</p><p><strong>指针网络(pointer network)</strong> 是一种序列到序列模型，其输入是长度为$n$的向量序列$X=\boldsymbol x_1, \cdots, \boldsymbol x_n$，输出是<strong>下标序列</strong>$c_{1:m}=c_1,c_2,\cdots,c_m, c_i \in [1,n], \forall i$。</p><p>和一般的序列到序列任务不同，这里的<strong>输出序列是输入序列的下标(索引)</strong>。比如输入一组乱序的数字，输出为按大小排序的输入数字序列的下标。比如<strong>输入为20*,* 5*,* 10，输出为1*,* 3*,* 2</strong>。</p><p>条件概率$p(c_{1:m}|\boldsymbol x_{1:n})$可以写为</p>$$
\begin{aligned}
p(c_{1: m} | \boldsymbol{x}_{1: n}) &=\prod_{i=1}^{m} p(c_{i} | c_{1: i-1}, \boldsymbol{x}_{1: n}) \\
& \approx \prod_{i=1}^{m} p(c_{i} | \boldsymbol{x}_{c_{1}}, \cdots, \boldsymbol{x}_{c_{i-1}}, \boldsymbol{x}_{1: n})
\end{aligned}
$$<p>其中条件概率$p(c_{i} | \boldsymbol{x}_{c_{1}}, \cdots, \boldsymbol{x}_{c_{i-1}}, \boldsymbol{x}_{1: n})$可以通过注意力分布来计算。假设用一个循环神经网络对$\boldsymbol{x}_{c_{1}}, \cdots, \boldsymbol{x}_{c_{i-1}}, \boldsymbol{x}_{1: n}$进行编码得到向量$\boldsymbol h_i$，则</p>$$
p(c_{i} | c_{1: i-1}, \boldsymbol{x}_{1: n})=\operatorname{softmax}(s_{i, j})
$$<p>其中$s_{i,j}$为在解码过程的第$i$步时，每个输入向量的未归一化的注意力分布：</p>$$
s_{i, j}=\boldsymbol{v}^{\mathrm{T}} \tanh (W \boldsymbol{x}_{j}+U \boldsymbol{h}_{i}), \forall j \in[1, n]
$$<p>根据传统的注意力机制，所谓的$s_{i,j}$正是针对输入序列的权重，完全可以<strong>把它拿出来作为指向输入序列的指针，在每次预测一个元素的时候找到输入序列中权重最大的那个元素</strong>。这便是指针网络对于传统注意力机制的简化。</p><p>下图给出了指针网络的示例：</p><div align=center><img src=/Kimages/3/image-20201004221027115.png style=zoom:30%></div><h2 id=自注意力模型>自注意力模型</h2><p>当使用神经网络来处理一个变长的向量序列时，我们通常可以使用卷积网络或循环网络进行编码来得到一个相同长度的输出向量序列，如下图所示：</p><div align=center><img src=/Kimages/3/image-20201004230604413.png style=zoom:30%></div><p>基于卷积或循环网络的序列编码都可以看做是一种局部的编码方式，只建模了输入信息的局部依赖关系。虽然循环网络理论上可以建立长距离依赖关系，但是由于信息传递的容量以及梯度消失问题，实际上也只能建立短距离依赖关系。</p><p>如果要建立输入序列之间的长距离依赖关系，可以使用以下两种方法：一种方法是增加网络的层数，通过一个<strong>深层网络</strong>来获取远距离的信息交互；另一种方法是使用<strong>全连接网络</strong>。全连接网络是一种非常直接的建模远距离依赖的模型，但是无法处理变长的输入序列。不同的输入长度，其连接权重的大小也是不同的。自注意力也称为<strong>内部注意力(intra-attention)</strong>。这时我们就可以利用注意力机制来“动态”地生成不同连接的权重，这就是<strong>自注意力模型(self-attention model)</strong>。</p><p>假设输入序列为$X=[\boldsymbol x_1, \cdots, \boldsymbol x_N] \in \mathbb R^{d_1 \times N}$，输出序列为$H=[\boldsymbol h_1, \cdots, \boldsymbol h_N] \in \mathbb R^{d_2 \times N}$，首先我们可以通过线性变换得到<strong>三组向量序列</strong>：</p>$$
\begin{aligned}
Q&=W_{Q} X \in \mathbb{R}^{d_{3} \times N} \\
K&=W_{K} X \in \mathbb{R}^{d_{3} \times N} \\
V&=W_{V} X \in \mathbb{R}^{d_{2} \times N}
\end{aligned}
$$<p>其中$Q,K,V$分别为查询向量序列，键向量序列和值向量序列，$W_Q \in \mathbb R^{d_3 \times d_1}, W_K \in \mathbb R^{d_3 \times d_1}, W_V \in \mathbb R^{d_2 \times d_1}$分别为可学习的参数矩阵。利用键值对注意力机制的公式，可以得到输出向量$\boldsymbol h_i$：</p>$$
\begin{aligned}
\boldsymbol{h}_{i} &=\operatorname{att}((K, V), \boldsymbol{q}_{i}) \\
&=\sum_{j=1}^{N} \alpha_{i j} \boldsymbol{v}_{j} \\
&=\sum_{j=1}^{N} \operatorname{softmax}(s(\boldsymbol{k}_{j}, \boldsymbol{q}_{i})) \boldsymbol{v}_{j}
\end{aligned}
$$<p>其中$i,j \in [1,N]$为输出和输入向量序列的位置，连接权重$\alpha_{ij}$由注意力机制动态生成。</p><p>如果使用缩放点积来作为注意力打分函数，则输出向量序列可以写为：</p>$$
H=V \text{softmax}(\frac{K^TQ}{\sqrt{d_3}})
$$<p>其中softmax为<strong>按列进行归一化</strong>的函数。</p><p>自注意力模型可以作为神经网络中的一层来使用，既可以用来替换卷积层和循环层，也可以和它们一起交替使用(比如$X$可以是<strong>卷积层或循环层的输出</strong>)。自注意力模型计算的权重$\alpha_{ij}$只依赖$\boldsymbol q_i$和$\boldsymbol k_j$的相关性，而忽略了输入信息的位置信息。因此在单独使用时，自注意力模型一般需要加入<strong>位置编码信息</strong>来进行修正。</p><h1 id=外部记忆>外部记忆</h1><h2 id=人脑中的记忆>人脑中的记忆</h2><p>记忆在大脑皮层是<strong>分布式存储</strong>的，而不是存储于某个局部区域。人脑中的记忆具有周期性和联想性：</p><p>(1) 记忆周期</p><p>人脑记忆的一个特点是，记忆一般分为长期记忆和短期记忆。<strong>长期记忆(long-term memory)</strong>，也称为结构记忆或<strong>知识(knowledge)</strong>，体现为神经元之间的连接形态，其更新速度比较慢。**短期记忆(short-term memory)**体现为神经元的活动，更新较快，维持时间为几秒至几分钟。短期记忆是神经连接的暂时性强化，通过不断巩固、强化可形成长期记忆。短期记忆、长期记忆的动态更新过程称为演化（Evolution）过程。</p><p>因此，长期记忆可以类比于人工神经网络中的<strong>权重参数</strong>，而短期记忆可以类比于人工神经网络中的<strong>隐状态</strong>。</p><p>除了长期记忆和短期记忆，人脑中还会存在一个“缓存”，称为<strong>工作记忆(working memory)</strong>。在执行某个认知行为(比如记下电话号码，算术运算)时，工作记忆是一个记忆的临时存储和处理系统，维持时间通常为<strong>几秒钟</strong>。从时间上看，<strong>工作记忆也是一种短期记忆</strong>，但和短期记忆的内涵不同。短期记忆一般指外界的输入信息在人脑中的表示和短期存储，不关心这些记忆如何被使用；而<strong>工作记忆是一个和任务相关的“容器”，可以临时存放和某项任务相关的短期记忆和其它相关的内在记忆</strong>。工作记忆的容量比较小，一般可以容纳4组项目。</p><p>(2) 联想记忆</p><p>大脑记忆的一个主要特点是通过联想来进行检索的。<strong>联想记忆(associative memory)<strong>是指一种</strong>学习和记住不同对象之间关系的能力</strong>，比如看见一个人然后想起他的名字，或记住某种食物的味道等。联想记忆指一种可以通过内容匹配的方法进行寻址的信息存储方式，也称为<strong>基于内容寻址的存储(content addressable memory, CAM)</strong>；现代计算机的存储方式是根据地址来进行存储的，称为<strong>随机访问存储(random access memory, RAM)</strong>。</p><p>和LSTM中的<strong>记忆单元</strong>相比，<strong>外部记忆可以存储更多的信息，并且不直接参与计算，通过读写接口来进行操作</strong>。而LSTM模型中的记忆单元包含了信息存储和计算两种功能，不能存储太多的信息。</p><p>借鉴人脑中工作记忆，可以在神经网络中引入一个<strong>外部记忆单元</strong>来提高网络容量。外部记忆的实现途径有两种：一种是<strong>结构化的记忆</strong>，这种记忆和计算机中的信息存储方法比较类似，可以分为多个记忆片段，并按照一定的结构来存储；另一种是<strong>基于神经动力学的联想记忆</strong>，这种记忆方式具有更好的生物学解释性。</p><h2 id=结构化的外部记忆>结构化的外部记忆</h2><p>为增强网络容量，一种简单的方式是引入结构化的记忆模块，<strong>将和任务相关的短期记忆保存在记忆中，需要时再进行读取</strong>。这种装备外部记忆的神经网络也称为<strong>记忆网络(memory network, MN)</strong> 或<strong>记忆增强神经网络(memory augmented neural network, MANN)</strong>。</p><p>记忆网络结构如下所示，一般由以下几个模块构成：</p><div align=center><img src=/Kimages/3/image-20201005101509539.png style=zoom:30%></div><p>(1) <strong>主网络(控制器)</strong>$C$：负责信息处理，并与外界进行交互(接受外界的输入信息并产生输出到外界)。主网络还同时通过读写模块和外部记忆进行交互。</p><p>(2) <strong>外部记忆单元</strong>$M$：外部记忆单元用来存储信息，一般可以分为很多<strong>记忆片段(memory segment)</strong>，这些片段按照一定的结构来进行组织。<strong>记忆片段一般用向量来表示</strong>，外部记忆单元可以用<strong>一组向量</strong>$\boldsymbol m_{1:N}=[\boldsymbol m_1, \cdots, \boldsymbol m_N]$来表示。<strong>这些向量的组织方式可以是集合、树、栈或队列等</strong>。大部分信息存储于外部记忆中，<strong>不需要全时参与主网络的运算</strong>。</p><p>(3) <strong>读取模块</strong>$R$：根据主网络生成的查询向量$\boldsymbol q_r$，从外部记忆单元中读取相应的信息$\boldsymbol r=R(\boldsymbol m_{1:N},\boldsymbol q_r)$。</p><p>(4) <strong>写入模块</strong>$W$：根据主网络生成的查询向量$\boldsymbol q_w$和要写入的信息$\boldsymbol a$来更新外部记忆$\boldsymbol m_{1:N}=W(\boldsymbol m_{1:N},\boldsymbol q_w,\boldsymbol a)$。</p><p>这种结构化的外部记忆是带有地址的，即每个记忆片段都可以按地址读取和写入。<strong>要实现类似于人脑神经网络的联想记忆能力，就需要按内容寻址的方式进行定位，然后进行读取或写入操作</strong>。按内容寻址通常使用<strong>注意力机制</strong>来进行。通过注意力机制可以实现一种 <strong>“软性”的寻址方式</strong>，即<strong>计算一个在所有记忆片段上的分布，而不是一个单一的绝对地址</strong>。比如读取模块$R$的实现方式可以为：</p>$$
\begin{aligned}
\boldsymbol{r} &=\sum_{i=1}^{N} \alpha_{i} \boldsymbol{m}_{i} \\
\alpha_{i} &=\operatorname{softmax}(s(\boldsymbol{m}_{i}, \boldsymbol{q}_{r}))
\end{aligned}
$$<p>其中$\boldsymbol q_r$是主网络生成的查询向量，$s(\cdot, \cdot)$为打分函数。类比于计算机的存储器读取，<strong>计算注意力分布的过程相当于是计算机的“寻址”过程</strong>，信息加权平均的过程相当于计算机的“内容读取”过程。因此，结构化的外部记忆也是一种联想记忆，只是其结构以及读写的操作方式更像是受计算机架构的启发。</p><p>通过引入外部记忆，可以将神经网络的参数和记忆容量“分离”，即<strong>在少量增加网络参数的条件下可以大幅增加网络容量</strong>。注意力机制可以看做是一个<strong>接口</strong>，将信息的存储于计算分离。</p><h3 id=端到端记忆网络>端到端记忆网络</h3><p><strong>端到端记忆网络(end-to-end memory network, MemN2N)</strong> 采用一种可微的网络结构，可以多次从外部信息中读取信息。在端到端记忆网络中，外部记忆单元是只读的。</p><p>给定一组需要存储的信息$\boldsymbol m_{1:N}=\{\boldsymbol m_1, \cdots, \boldsymbol m_N\}$，其中每个$\boldsymbol m_i$是一个向量，首先将$\boldsymbol m_{1:N}$转换为两组<strong>记忆片段</strong>$A=[\boldsymbol a_1, \cdots, \boldsymbol a_N]$和$C=[\boldsymbol c_1, \cdots, \boldsymbol c_N]$(<strong>原文中利用两个embedding矩阵实现</strong>)，分别存放在两个外部记忆单元中，其中$A$用来寻址，$C$用来进行输出。主网络根据输入$\boldsymbol x$生成$\boldsymbol q$(<strong>原文利用embeddding矩阵实现</strong>)，并使用注意力机制来从外部记忆中读取相关信息$\boldsymbol r$：</p>$$
r=\sum_{i=1}^{N} \operatorname{softmax}(\boldsymbol{a}_{i}^{\mathrm{T}} \boldsymbol{q}) \boldsymbol{c}_{i}
$$<p>并产生输出$\boldsymbol y=f(\boldsymbol q+\boldsymbol r)$，其中$f(\cdot)$为预测函数。当应用到分类任务时，$f(\cdot)$可以设为softmax函数。</p><p>为了实现更复杂的计算，可以让主网络和外部记忆进行多轮交互。在第$k$轮交互中，主网络根据上次从外部记忆中读取的信息$\boldsymbol r^{(k-1)}$，产生新的查询向量$\boldsymbol{q}^{(k)}=\boldsymbol{r}^{(k-1)}+\boldsymbol{q}^{(k-1)}$，其中$\boldsymbol q^{(0)}$为初始查询向量，$\boldsymbol r^{(0)}=0$。</p><p>假设第$k$轮交互的外部记忆为$A^{(k)}$和$C^{(k)}$，主网络从外部记忆读取信息为：</p>$$
\boldsymbol{r}^{(k)}=\sum_{i=1}^{N} \operatorname{softmax}((\boldsymbol{a}_{i}^{(k)})^{\mathrm{T}} \boldsymbol{q}^{(k)}) \boldsymbol{c}_{i}^{(k)}
$$<p>在$K$轮交互后，用$\boldsymbol y=f(\boldsymbol q^{(K)}+\boldsymbol r^{(K)})$进行预测。这种多轮的交互方式也称为 <strong>多跳(multi-hop)</strong> 操作。多跳操作中的参数一般是共享的，为了简化起见，每轮交互的外部记忆也可以共享使用，比如$A^{(1)}=\cdots=A^{(K)}$。</p><p>端到端记忆网络结构如下所示：</p><div align=center><img src=/Kimages/3/image-20201005120052297.png style=zoom:30%></div><h3 id=神经图灵机>神经图灵机</h3><p><strong>神经图灵机(neural Turing machine, NTM)</strong> 主要由两个部件构成：控制器和外部记忆。<strong>外部记忆</strong>定义为矩阵$M \in \mathbb R^{d \times N}$，其中$N$是记忆片段的数量，$d$是每个记忆片段的大小。<strong>控制器</strong>为一个前馈或循环神经网络。神经图灵机中的外部记忆是可读写的，其结构如下所示：</p><div align=center><img src=/Kimages/3/image-20201028105252105.png style=zoom:40%></div><p>在每个时刻$t$，控制器接受当前时刻的输入$\boldsymbol x_t$、上一时刻的输出$\boldsymbol h_{t-1}$和上一时刻从外部记忆中读取的信息$\boldsymbol r_{t-1}$，并产生输出$\boldsymbol h_t$，同时生成和读写外部记忆相关的三个向量：查询向量$\boldsymbol q_t$、删除向量$\boldsymbol e_t$和增加向量$\boldsymbol a_t$，然后对外部记忆$M_t$进行读写操作，生成读向量$\boldsymbol r_t$和新的外部记忆$M_{t+1}$。</p><p>(1) 读操作</p><p>在时刻$t$，外部记忆的内容记为$M_t=[\boldsymbol{m}_{t, 1}, \cdots, \boldsymbol{m}_{t, n}]$，读操作为从外部记忆$M_t$中读取信息$\boldsymbol r_t \in \mathbb R^d$。</p><p>首先通过注意力机制来进行基于内容的寻址，即$\alpha_{t, i}=\operatorname{softmax}(s(\boldsymbol{m}_{t, i}, \boldsymbol{q}_{t}))$，其中$\boldsymbol q_t$为控制器产生的查询向量，用来进行基于内容的寻址。函数$s(\cdot,\cdot)$为加性或乘性的打分函数。注意力分布$\alpha_{t, i}$是记忆片段$\boldsymbol m_{t, i}$对应的权重，并满足$\sum_{i=1}^{n} \alpha_{t, i}=1$。根据注意力分布$\alpha_t$，可以计算读向量$\boldsymbol r_t$作为下一个时刻控制器的输入：</p>$$
\boldsymbol{r}_{t}=\sum_{i=1}^{n} \alpha_{i} \boldsymbol{m}_{t, i}
$$<p>(2) 写操作</p><p>外部记忆的写操作可以分解为两个子操作：<strong>删除和增加</strong>。</p><p>首先，控制器产生删除向量$\boldsymbol e_t$和增加向量$\boldsymbol a_t$，分别为要从外部记忆中删除的信息和要增加的信息。</p><p>删除操作是<strong>根据注意力分布</strong>来按比例地在每个记忆片段中删除$\boldsymbol e_t$，增加操作是<strong>根据注意力分布</strong>来按比例地给每个记忆片段加入$\boldsymbol a_t$：</p>$$
\boldsymbol{m}_{t+1, i}=\boldsymbol{m}_{t, i}(\mathbf{1}-\alpha_{t, i} )\boldsymbol{e}_{t}+\alpha_{t, i} \boldsymbol{a}_{t}, \forall i \in[1, n]
$$<p>通过写操作得到下一时刻的外部记忆$M_{t+1}$。</p><h1 id=参考资料>参考资料</h1><ul><li>邱锡鹏. 神经网络与深度学习. 北京: 机械工业出版社, 2020.</li><li>生物神经网络基础：https://www.jiqizhixin.com/articles/spiking-neurons</li><li>Attention机制维基百科：https://en.wikipedia.org/wiki/Attention_(machine_learning)</li></ul><hr><ul class=pager><li class=previous><a href=/post/4-dl/dl7-%E6%B7%B1%E5%BA%A6%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/ data-toggle=tooltip data-placement=top title=深度学习：深度生成模型>&larr;
Previous Post</a></li><li class=next><a href=/post/4-dl/dl9-%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/ data-toggle=tooltip data-placement=top title=深度学习：图神经网络>Next
Post &rarr;</a></li></ul><script src=https://giscus.app/client.js data-repo=XiangdiWu/XiangdiWu.github.io data-repo-id=R_kgDOP0pDUQ data-category=Announcements data-category-id=DIC_kwDOP0pDUc4CvwjG data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=light data-lang=zh-CN crossorigin=anonymous async></script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/deep-learning title="deep learning">deep learning
</a><a href=/tags/machine-learning title="machine learning">machine learning
</a><a href=/tags/math title=math>math
</a><a href=/tags/model title=model>model
</a><a href=/tags/nlp title=nlp>nlp
</a><a href=/tags/quant title=quant>quant</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://www.factorwar.com/data/factor-models/>GetAstockFactors</a></li><li><a target=_blank href=https://datawhalechina.github.io/whale-quant/#/>Whale-Quant</a></li></ul></section></div></div></div></article><script type=module>  
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
    mermaid.initialize({ startOnLoad: true });  
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerHTML}</div>`})</script><style>.mermaid svg{display:block;margin:auto}</style><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:bernicewu2000@outlook.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat_qrcode.jpg><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/xiangdiwu><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="Xiangdi Blog"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; Xiangdi Blog 2025</p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){n=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),t=$(this).text(),i=$('<a href="'+o+'" rel="nofollow" title="'+t+'">'+t+"</a>"),s=$('<li class="'+n+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script><style>.markmap>svg{width:100%;height:300px}</style><script>window.markmap={autoLoader:{manual:!0,onReady(){const{autoLoader:e,builtInPlugins:t}=window.markmap;e.transformPlugins=t.filter(e=>e.name!=="prism")}}}</script><script src=https://cdn.jsdelivr.net/npm/markmap-autoloader></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css integrity="sha512-r2+FkHzf1u0+SQbZOoIz2RxWOIWfdEzRuYybGjzKq18jG9zaSfEy9s3+jMqG/zPtRor/q4qaUCYQpmSjTw8M+g==" crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js integrity="sha512-INps9zQ2GUEMCQD7xiZQbGUVnqnzEvlynVy6eqcTcHN4+aQiLo9/uaQqckDpdJ8Zm3M0QBs+Pktg4pz0kEklUg==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/mhchem.min.js integrity="sha512-mxjNw/u1lIsFC09k/unscDRY3ofIYPVFbWkP8slrePcS36ht4d/OZ8rRu5yddB2uiqajhTcLD8+jupOWuYPebg==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js integrity="sha512-YJVxTjqttjsU3cSvaTRqsSl0wbRgZUNF+NGGCgto/MUbIvaLdXQzGTCQu4CvyJZbZctgflVB0PXw9LLmTWm5/w==" crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"},{display:!0,left:"\\[",right:"\\]"}],errorcolor:"#CD5C5C",throwonerror:!1})'></script></body></html>