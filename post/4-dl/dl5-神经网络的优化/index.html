<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="Xiangdi Blog"><meta property="og:type" content="article"><meta property="og:image" con ’tent=https://images.pexels.com/photos/220301/pexels-photo-220301.jpeg><meta property="twitter:image" content="https://images.pexels.com/photos/220301/pexels-photo-220301.jpeg"><meta name=title content="深度学习：神经网络的优化"><meta property="og:title" content="深度学习：神经网络的优化"><meta property="twitter:title" content="深度学习：神经网络的优化"><meta name=description content="本文主要介绍神经网络的优化，包括网络结构多样性、高维变量的非凸优化、优化算法、参数初始化等。"><meta property="og:description" content="本文主要介绍神经网络的优化，包括网络结构多样性、高维变量的非凸优化、优化算法、参数初始化等。"><meta property="twitter:description" content="本文主要介绍神经网络的优化，包括网络结构多样性、高维变量的非凸优化、优化算法、参数初始化等。"><meta property="twitter:card" content="summary"><meta property="og:url" content="https://xiangdiwu.github.io/post/4-dl/dl5-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BC%98%E5%8C%96/"><meta name=keyword content="吴湘菂, WuXiangdi, XiangdiWu, 吴湘菂的网络日志, 吴湘菂的博客, Xiangdi Blog, 博客, 个人网站, Quant, 量化投资, 金融, 投资, 理财, 股票, 期货, 基金, 期权, 外汇, 比特币"><link rel="shortcut icon" href=/img/favicon.ico><title>深度学习：神经网络的优化-吴湘菂的博客 | Xiangdi Blog</title><link rel=canonical href=/post/4-dl/dl5-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BC%98%E5%8C%96/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.min.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/hux-blog.min.js></script><script src=/js/lazysizes.min.js></script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-R757MDJ6Y6"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-R757MDJ6Y6")}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"\\[",right:"\\]",display:!0},{left:"$$",right:"$$",display:!0},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})})</script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type=text/javascript></script><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Xiangdi Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/quant/>quant</a></li><li><a href=/categories/reading/>reading</a></li><li><a href=/categories/tech/>tech</a></li><li><a href=/archive//>ARCHIVE</a></li><li><a href=/vibe//>Vibe</a></li><li><a href=/travel//>TRAVEL</a></li><li><a href=/about//>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(https://images.pexels.com/photos/220301/pexels-photo-220301.jpeg)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/quant title=Quant>Quant
</a><a class=tag href=/tags/model title=Model>Model
</a><a class=tag href=/tags/deep-learning title="Deep Learning">Deep Learning</a></div><h1>深度学习：神经网络的优化</h1><h2 class=subheading>Optimisation of Neural Networks</h2><span class=meta>Posted by
XiangdiWu
on
Thursday, October 15, 2020</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h1 id=网络优化的难点>网络优化的难点</h1><h2 id=网络结构多样性>网络结构多样性</h2><p>神经网络的种类非常多，比如卷积网络、循环网络等，其结构也非常不同。有些比较深，有些比较宽。不同参数在网络中的作用也有很大的差异，比如连接权重和偏置的不同，以及循环网络中循环连接上的权重和其它权重的不同。由于网络结构的多样性，我们很难找到一种通用的优化方法。<strong>不同的优化方法在不同网络结构上的差异也都比较大</strong>。此外，网络的超参数一般也比较多，这也给优化带来很大的挑战。</p><h2 id=高维变量的非凸优化>高维变量的非凸优化</h2><p>低维空间的非凸优化问题主要是存在一些局部最优点。基于梯度下降的优化方法会陷入局部最优点，因此低维空间非凸优化的主要难点是如何选择初始化参数和逃离局部最优点。深度神经网络的参数非常多，其参数学习是在非常高维空间中的非凸优化问题，其挑战和在低维空间的非凸优化问题有所不同。在高维空间中，非凸优化的难点并不在于如何逃离局部最优点，而是如何逃离<strong>鞍点(saddle point)</strong>。鞍点的叫法是因为其形状像马鞍。鞍点的梯度是0，但是在一些维度上是最高点，在另一些维度上是最低点。</p><div align=center><img src=/Kimages/3/image-20200613202435836.png style=zoom:25%></div><p>在高维空间中，局部最优点要求<strong>在每一维度上都是最低点</strong>，<strong>这种概率非常低</strong>。假设网络有10,000维参数，一个点在某一维上是局部最低点的概率为$p$，那么在整个参数空间中，局部最优点的概率为$p^{10,000}$，这种可能性非常小。也就是说<strong>高维空间中，大部分梯度为0的点都是鞍点</strong>。基于梯度下降的优化方法会<strong>在鞍点附近接近于停滞</strong>，同样很难从这些鞍点中逃离。</p><p>深度神经网络的参数非常多，并且冗余性很高，这使得每个参数对最终损失的影响都比较小，这导致了损失函数在局部最优点附近是一个平坦的区域，称为<strong>平坦最小值(flat minima)</strong>。</p><div align=center><img src=/Kimages/3/image-20200613202647979.png style=zoom:30%></div><p>目前，深度神经网络的参数学习主要是通过梯度下降法来寻找一组可以最小化结构风险的参数。在具体实现中，梯度下降法可以分为<strong>批量梯度下降、随机梯度下降以及小批量梯度下降</strong>三种形式。除了在收敛效果和效率上的差异，这三种方法都存在一些共同的问题，比如<strong>如何改进优化算法、如何初始化参数、如何预处理数据等</strong>。</p><h1 id=优化算法>优化算法</h1><h2 id=小批量梯度下降>小批量梯度下降</h2><p>在训练深度神经网络时，训练数据的规模通常都比较大。如果在梯度下降时，每次迭代都要计算整个训练数据上的梯度，这就需要比较多的计算资源。另外大规模训练集中的数据通常会非常冗余，也没有必要在整个训练集上计算梯度。因此，在训练深度神经网络时，经常使用<strong>小批量梯度下降法(mini-batch gradient descent)</strong>，即<strong>仅在训练集中选择一个较小的子集来更新梯度</strong>。</p><p>影响小批量梯度下降法的因素有：(1) 批量大小$K$；(2) 学习率$\alpha$；(3) 梯度估计。为了更有效地训练深度神经网络，在标准的小批量梯度下降法的基础上，也经常使用一些改进方法以加快优化速度，比如如何<strong>选择批量大小</strong>、如何<strong>调整学习率</strong>以及如何<strong>修正梯度估计</strong>。</p><h2 id=批量大小选择>批量大小选择</h2><p>在小批量梯度下降法中，<strong>批量大小(batch size)</strong> 对网络优化的影响非常大。一般而言，<strong>批量大小不影响随机梯度的期望，但是会影响随机梯度的方差</strong>。批量大小越大，随机梯度的<strong>方差越小</strong>，引入的噪声也越小，训练也越稳定，因此可以设置<strong>较大的学习率</strong>。批量大小较小时，需要设置较小的学习率，否则模型会<strong>不收敛</strong>。学习率通常要随着批量大小的增大而相应地增大。一个简单有效的方法是<strong>线性缩放规则</strong>：当批量大小增加$m$倍时，学习率也增加$m$倍。线性缩放规则往往在批量大小较小时适用，当批量大小非常大时，线性缩放会使训练不稳定。</p><p>下图给出了从epoch(回合)和iteration(更新次数)的角度，批量大小对损失下降的影响：</p><div align=center><img src=/Kimages/3/image-20200613203340367.png style=zoom:35%></div><div align=center><img src=/Kimages/3/image-20200613203411932.png style=zoom:35%></div><p>从epoch图可以看出，可以看出，<strong>批量样本数越小，适当小的批量大小会导致更快的收敛</strong>；从iteration图可以看出，<strong>批量大小越大，下降效果越明显，并且下降曲线越平滑</strong>。</p><h2 id=学习率调整>学习率调整</h2><p>学习率是神经网络优化时的重要超参数。在梯度下降法中，学习率的取值非常关键，如果<strong>过大就不会收敛</strong>，如果<strong>过小则收敛速度太慢</strong>。常用的学习率调整方法包括<strong>学习率衰减、学习率预热、周期性学习率调整</strong>以及一些<strong>自适应调整学习率的方法</strong>，如<strong>AdaGrad、RMSprop、AdaDelta</strong>等。自适应学习率方法可针对每个参数设置不同的学习率。</p><h3 id=学习率衰减>学习率衰减</h3><p>从经验上看，学习率在一开始要保持大些来保证收敛速度，在收敛到最优点附近时要小些以避免来回震荡。简单的学习率调整可通过<strong>学习率衰减(learning rate decay)<strong>来实现，也称为</strong>学习率退火(learning rate annealing)</strong>。不失一般性，衰减方式设置为<strong>按迭代次数进行衰减</strong>。假设初始化学习率为$\alpha_0$，在第$t$次迭代时的学习率$\alpha_t$，衰减率一般用$\beta$表示。常见的衰减方法有以下几种：</p><p>(1) <strong>分段常数衰减(piecewise constant decay)</strong>：每经过$T_1,T_2,\cdots$次迭代将学习率衰减为原来的$\beta_1,\beta_2,\cdots$倍，其中$T_i和$$\beta_i$为根据经验设置的超参数。分段常数衰减也称为<strong>步衰减(step decay)</strong>。</p><p>(2) <strong>逆时衰减(inverse time decay)</strong>：</p>$$
\alpha_{t}=\alpha_{0} \frac{1}{1+\beta \times t}
$$<p>(3) <strong>指数衰减(exponential decay)</strong>：</p>$$
\alpha_{t}=\alpha_{0} \beta^{t}
$$<p>(4) <strong>自然指数衰减(natural exponential decay)</strong>：</p>$$
\alpha_{t}=\alpha_{0} \exp (-\beta \times t)
$$<p>(5) <strong>余弦衰减(cosine decay)</strong>：</p>$$
\alpha_{t}=\frac{1}{2} \alpha_{0}\left(1+\cos \left(\frac{t \pi}{T}\right)\right)
$$<p>下图给出了不同衰减方法的示例(假设<strong>初始学习率为1</strong>)。</p><div align=center><img src=/Kimages/3/image-20200613204216218.png style=zoom:35%></div><h3 id=学习率预热>学习率预热</h3><p>在小批量梯度下降法中，当批量大小的设置比较大时，通常需要比较大的学习率。但在刚开始训练时，由于参数是随机初始化的，梯度往往也比较大，再加上比较大的初始学习率，会使得训练不稳定。为了提高训练稳定性，我们可以<strong>在最初几轮迭代时，采用比较小的学习率</strong>，等梯度下降到一定程度后再恢复到初始的学习率，这种方法称为<strong>学习率预热(learning rate warmup)</strong>。</p><p>一个常用的学习率预热方法是<strong>逐渐预热(gradual warmup)</strong>。假设预热的迭代次数为$T'$，初始学习率为$\alpha_0$，在预热过程中，每次更新的学习率为：</p>$$
\alpha_{t}^{\prime}=\frac{t}{T^{\prime}} \alpha_{0}, \quad 1 \leq t \leq T^{\prime}
$$<p><strong>当预热过程结束，再选择一种学习率衰减方法来逐渐降低学习率</strong>。</p><h3 id=学习率周期性调整>学习率周期性调整</h3><p>为了使得梯度下降法能够逃离局部最小值或鞍点，一种经验性的方式是在训练过程中<strong>周期性地增大学习率</strong>。虽然增大学习率可能短期内有损网络的收敛稳定性，但从长期来看<strong>有助于找到更好的局部最优解</strong>。一般而言，当一个模型收敛一个平坦的局部最小值时，其鲁棒性会更好，即微小的参数变动不会剧烈影响模型能力；而当模型收敛到一个尖锐的局部最小值时，其鲁棒性也会比较差。具备良好泛化能力的模型通常应该是鲁棒的，因此<strong>理想的局部最小值应该是平坦的</strong>。周期性学习率调整可以使得梯度下降法在优化过程中<strong>跳出尖锐的局部极小值</strong>，虽然会短期内会损害优化过程，但最终会收敛到更加理想的局部极小值。</p><p>常用的两种周期性学习率调整方法(三角循环学习率、带热重启的余弦衰减)如下所示：</p><div align=center><img src=/Kimages/3/image-20200613205808096.png style=zoom:25%></div><h2 id=梯度估计修正>梯度估计修正</h2><p>除了调整学习率之外，还可以进行<strong>梯度估计(gradient estimation)的修正</strong>。在随机(小批量)梯度下降法中，如果每次选取样本数量比较小，损失会<strong>呈现震荡的方式下降</strong>。也就是说，随机梯度下降方法中每次迭代的梯度估计和整个训练集上的最优梯度并不一致，具有一定的随机性。一种有效地缓解梯度估计随机性的方式是<strong>通过使用最近一段时间内的平均梯度来代替当前时刻的随机梯度作为参数更新的方向，从而提高优化速度</strong>。</p><p>(1) <strong>动量法(momentum method)</strong>：用之前积累动量替代真正的梯度。每次迭代的梯度可以看作是加速度。在第$t$次迭代时，计算负梯度的“加权移动平均”作为参数的更新方向，</p>$$
\Delta \theta_{t}=\rho \Delta \theta_{t-1}-\alpha \boldsymbol{g}_{t}=-\alpha \sum_{\tau=1}^{t} \rho^{t-\tau} \boldsymbol{g}_{\tau}
$$<p>其中$\rho$为动量因子，通常设为0.9，$\alpha$为学习率。</p><p>(2) <strong>Nesterov加速梯度(nesterov accelerated gradient, NAG)</strong>：一种对动量法的改进。</p><p>在动量法中，实际的参数更新方向$\Delta \theta_t$为<strong>上一步的参数更新方向</strong>$\Delta \theta_{t-1}$和<strong>当前梯度的反方向</strong>$-\boldsymbol g_t$的<strong>叠加</strong>。这样，$\Delta \theta_t$可以被拆分为两步进行，先根据更新一次$\Delta \theta_{t-1}$得到参数$\hat \theta$，再用$-\boldsymbol g_t$进行更新。</p>$$
\begin{aligned}
\hat{\theta} &=\theta_{t-1}+\rho \Delta \theta_{t-1} \\
\theta_{t} &=\hat{\theta}-\alpha \boldsymbol{g}_{t}
\end{aligned}
$$<p>其中梯度$-\boldsymbol g_t$为点$\Delta \theta_{t-1}$上的梯度，因此在第二步更新中有些不太合理。更合理的更新方向应该为$\hat \theta$上的梯度。这样，合并后的更新方向为：</p>$$
\Delta \theta_{t}=\rho \Delta \theta_{t-1}-\alpha \mathfrak{g}_{t}(\theta_{t-1}+\rho \Delta \theta_{t-1})
$$<p>其中$\mathfrak{g}_{t}(\theta_{t-1}+\rho \Delta \theta_{t-1})$表示损失函数在点$\hat{\theta}=\theta_{t-1}+\rho \Delta \theta_{t-1}$上的偏导数。</p><p>下图给出了动量法和Nesterov加速梯度在参数更新时的比较：</p><div align=center><img src=/Kimages/3/image-20200721100647751.png style=zoom:30%></div><p>(3) <strong>Adam(adaptive moment estimation)</strong> 可以看作动量法和RMSprop算法的结合，不但使用动量作为参数更新方向，而且可以自适应调整学习率。</p><p>(4) <strong>梯度截断(gradient clipping)</strong>：在深度神经网络或循环神经网络中，除了梯度消失之外，梯度爆炸也是影响学习效率的主要因素。在基于梯度下降的优化过程中，如果梯度突然增大，用大的梯度更新参数反而会导致其远离最优点。为了避免这种情况，当梯度的模大于一定阈值时，就对梯度进行截断，称为梯度截断。</p><h1 id=参数初始化>参数初始化</h1><p>神经网络训练过程中的参数学习是基于梯度下降法进行优化的。梯度下降法需要在开始训练时给每一个参数赋一个初始值。这个初始值的选取十分关键。在<strong>感知器和logistic回归</strong>的训练中，我们一般将参数<strong>全部初始化为0</strong>。但是这<strong>在神经网络的训练中会存在一些问题</strong>。因为如果参数都为0，在第一遍前向计算时，<strong>所有的隐层神经元的激活值都相同。这样会导致深层神经元没有区分性。这种现象也称为对称权重现象</strong>。</p><p><strong>随机初始化参数的一个问题是如何选取随机初始化的区间</strong>。如果参数取的太小，一是会导致神经元的输入过小，经过多层之后信号就慢慢消失了；二是还会使得sigmoid型激活函数丢失非线性的能力，因为sigmoid函数在0附近基本上是近似线性的。这样多层神经网络的优势也就不存在了。如果参数取的太大，会导致输入状态过大。对于sigmoid型激活函数来说，激活值变得饱和，从而导致梯度接近于0。</p><p>因此，要高效地训练神经网络，给参数选取一个合适的随机初始化区间是非常重要的。一般而言，参数初始化的区间应该<strong>根据神经元的性质进行差异化的设置</strong>。如果一个神经元的输入连接很多，它的每个输入连接上的权重就应该小一些，以避免神经元的输出过大(当激活函数为ReLU时)或过饱和(当激活函数为sigmoid函数时)。</p><p>经常使用的两种初始化方法有<strong>高斯分布初始化</strong>和<strong>均匀分布初始化</strong>。初始化一个深层网络时，一个比较好的初始化策略是<strong>保持每个神经元输入和输出的方差一致</strong>。</p><h2 id=xavier初始化glorot初始化>Xavier初始化(Glorot初始化)</h2><p>当网络使用<strong>logistic激活函数</strong>时，<strong>Xavier初始化</strong>可以根据每层的<strong>神经元数量</strong>来自动<strong>计算初始化参数的方差</strong>。假设第$l$层神经元的激活函数为logistic​函数，对于第$l-1$到$l$层的权重参数区间$r$可以设置为：</p>$$
r=\sqrt{\frac{6}{n^{l-1}+n^{l}}}
$$<p>其中$n^l$和$n^{l-1}$分别代表第$l$层和第$l-1$层神经元的数量。</p><p>对于tanh函数，$r$可以设置为：</p>$$
r=4 \sqrt{\frac{6}{n^{l-1}+n^{l}}}
$$<p>假设第$l$层的一个隐藏层神经元$z^l$，其接收前一层的$n^{l-1}$个神经元的输出$a_{i}^{(l-1)}, 1 \leqslant i \leqslant n^{(l-1)}$：</p>$$
z^{l}=\sum_{i=1}^{n^{(l-1)}} w_{i}^{l} a_{i}^{(l-1)}
$$<p>为了避免初始化参数使得激活值变得饱和，我们需要尽量使得$z^l$处于激活函数的线性区间，也就是其绝对值比较小的值。这时该神经元的激活值为$a^l=f(z^l) \approx z^l$。</p><p>假设$w_i^l$和$a_i^{l-1}$的均值都为0，并且互相独立，则$a^l$的均值为：</p>$$
\mathbb{E}[a^{l}]=\mathbb{E}\left[\sum_{i=1}^{n^{(l-1)}} w_{i}^{l} a_{i}^{(l-1)}\right]=\sum_{i=1}^{n^{(l-1)}} \mathbb{E}\left[\boldsymbol{w}_{i}\right] \mathbb{E}[a_{i}^{(l-1)}]=0
$$<p>$a^l$的方差为：</p>$$
\begin{aligned}
\operatorname{var}[a^{l}] &=\operatorname{var}[\sum_{i=1}^{n^{(l-1)}} w_{i}^{l} a_{i}^{(l-1)}] \\
&=\sum_{i=1}^{n^{(l-1)}} \operatorname{var}[w_{i}^{l}] \operatorname{var}[a_{i}^{(l-1)}] \\
&=n^{(l-1)} \operatorname{var}[w_{i}^{l}] \operatorname{var}[a_{i}^{(l-1)}]
\end{aligned}
$$<p>也就是说，输入信号的方差在经过该神经元后被放大或缩小了$n^{(l-1)} \operatorname{var}[w_{i}^{l}]$倍。为了使得在经过多层网络后，信号不被过分放大或过分减弱，我们尽可能保持每个神经元的输入和输出的方差一致。这样设$n^{(l-1)} \operatorname{var}[w_{i}^{l}]$为1比较合理，即：</p>$$
\operatorname{var}[w_{i}^{l}]=\frac{1}{n^{(l-1)}}
$$<p>同理，为了使得在<strong>反向传播</strong>中，误差信号也不被放大或缩小，需要将$w_i^l$的方差保持为：</p>$$
\operatorname{var}\left[w_{i}^{l}\right]=\frac{1}{n^{(l)}}
$$<p>作为折中，同时考虑信号在前向和反向传播中都不被放大或缩小，可以设置</p>$$
\operatorname{var}[w_{i}^{l}]=\frac{2}{n^{(l-1)}+n^{(l)}}
$$<p>在计算出<strong>参数的理想方差</strong>后，可以通过高斯分布或均匀分布来随机初始化参数。若采用高斯分布来随机初始化权重，连接权重$w_i^l$可以按照</p>$$
\mathcal{N}\left(0, \sqrt{\frac{2}{n^{(l-1)}}+n^{(l)}}\right)
$$<p>的高斯分布进行初始化；假设随机变量$x$在区间$[a, b]$内均匀分布，则其方差为：</p>$$
\operatorname{var}[x]=\frac{(b-a)^{2}}{12}
$$<p>因此，若采用区间为$[r,r]$的均分分布来初始化$w_i^l$，并满足$\operatorname{var}[w_{i}^{l}]=\frac{2}{n^{(l-1)}+n^{(l)}}$，则$r$的取值为</p>$$
r=\sqrt{\frac{6}{n^{l-1}+n^{1}}}
$$<h2 id=he初始化>He初始化</h2><p>当第$l$层神经元使用ReLU激活函数时，通常<strong>有一半的神经元输出为0</strong>，因此<strong>其分布的方差也近似为使用logistic作为激活函数时的一半</strong>。这样，<strong>只考虑前向传播</strong>时，参数的理想方差为：</p>$$
\operatorname{var}[w_{i}^{l}]=\frac{2}{n^{(l-1)}}
$$<p>其中$n^{(l-1)}$是第$l-1$层神经元个个数。因此当使用ReLU激活函数时，若采用高斯分布来初始化参数$w_i^l$，其方差为$\frac{2}{n^{(l-1)}}$；若采用区间为$[r, r]$的均分分布来初始化参数$w_i^l$，则$r=\sqrt{\frac{6}{n^{l-1}}}$。这种初始化方法称为$He$初始化。</p><h1 id=数据预处理>数据预处理</h1><p>一般而言，样本的原始特征中的每一维特征由于<strong>来源以及度量单位不同</strong>，其<strong>特征取值的分布范围往往差异很大</strong>。当我们计算不同样本之间的欧氏距离时，<strong>取值范围大的特征会起到主导作用</strong>。这样，对于基于相似度比较的机器学习方法(比如最近邻分类器)，必须先对样本进行预处理，将各个维度的特征归一化到同一个取值区间，并且消除不同特征之间的相关性，才能获得比较理想的结果。虽然<strong>神经网络可以通过参数的调整来适应不同特征的取值范围</strong>，但是会导致<strong>训练效率比较低</strong>，因为参数调整的过程需要花较长时间。</p><p>不同输入特征的取值范围差异比较大时，梯度下降法的效率也会受到影响。下图给出了<strong>数据归一化对梯度的影响</strong>。其中，下图(a)为未归一化数据的等高线图。取值范围不同会造成在大多数位置上的梯度方向并不是最优的搜索方向。当使用梯度下降寻求最优解时，需要很多次迭代才能收敛。</p><div align=center><img src=/Kimages/3/image-20200613210201201.png style=zoom:30%></div><p>在神经网络中常用的归一化方式有以下几种：</p><p>(1) <strong>缩放归一化</strong>：缩放归一化是一种非常简单的归一化方法，通过缩放将每一个特征的取值范围归一到$[0,1]$或$[-1,1]$之间。假设有$N$个样本，对于每一维特征$x^{(n)}$，</p>$$
\hat{x}^{(n)}=\frac{x^{(n)}-\min _{n}(x^{(n)})}{\max _{n}(x^{(n)})-\min _{n}(x^{(n)})}
$$<p>其中$\min(x)$和$\max(x)$分别是<strong>特征</strong>$x$在所有样本上的最小值和最大值。</p><p>(2) <strong>标准归一化</strong>：标准归一化也叫<strong>z-score归一化</strong>，来源于统计上的标准分数。<strong>将每一个维特征都调整为均值为0，方差为1</strong>。对于每一维特征$x^{(n)}$，先计算它的均值和方差：</p>$$
\begin{aligned}
\mu &=\frac{1}{N} \sum_{n=1}^{N} x^{(n)} \\
\sigma^{2} &=\frac{1}{N} \sum_{n=1}^{N}(x^{(n)}-\mu)^{2}
\end{aligned}
$$<p>然后，将特征$x^{(n)}$<strong>减去均值，并除以标准差</strong>，得到新的特征值$\hat x^{(n)}$：</p>$$
\hat{x}^{(n)}=\frac{x^{(n)}-\mu}{\sigma}
$$<p>这里$\sigma$不能为0。<strong>如果方差为0，说明这一维特征没有任务区分性，可以直接删掉</strong>。</p><p>(3) <strong>白化</strong>：一种重要的预处理方法，用来<strong>降低输入数据特征之间的冗余性</strong>。输入数据经过白化处理后，<strong>特征之间相关性较低，并且所有特征具有相同的方差</strong>。白化的一个主要实现方式是使用<strong>主成分分析(principal component analysis, PCA)</strong> 方法去除掉各个成分之间的相关性。下图给出了标准归一化和PCA白化的比较。</p><div align=center><img src=/Kimages/3/image-20200613211559224.png style=zoom:35%></div><h1 id=逐层归一化>逐层归一化</h1><p>在深度神经网络中，<strong>中间某一层的输入是其之前的神经层的输出</strong>。因此，<strong>其之前的神经层的参数变化会导致其输入的分布发生较大的差异</strong>。在使用随机梯度下降来训练网络时，每次参数更新都会导致网络中间每一层的输入的分布发生改变。越深的层，其输入的分布会改变得越明显。就像一栋高楼，低楼层发生一个较小的偏移，都会导致高楼层较大的偏移。</p><p>从机器学习角度来看，如果某个神经层的输入分布发生了改变，那么其参数需要重新学习，这种现象叫做<strong>内部协变量偏移(internal covariate shift)</strong>。</p><p>为了解决内部协变量偏移问题，就要使得每一个神经层的输入的分布在训练过程中保持一致。最<strong>简单直接的方法就是对每一个神经层都进行归一化操作，使其分布保持稳定</strong>。下面介绍几种比较常用的逐层归一化方法：批量归一化、层归一化和其它一些方法。</p><h2 id=批量归一化>批量归一化</h2><p><strong>批量归一化(batch normalization, BN)</strong> 方法是一种有效的逐层归一化方法，可以<strong>对神经网络中任意的中间层进行归一化操作</strong>。对于一个深度神经网络，令第$l$层的净输入为$\boldsymbol z^{(l)}$，神经元的输出为$\boldsymbol a^{(l)}$，即：</p>$$
\boldsymbol{a}^{(l)}=f(\boldsymbol{z}^{(l)})=f(W \boldsymbol{a}^{(l-1)}+\boldsymbol{b})
$$<p>为了减少内部协变量偏移问题，就要使得净输入$\boldsymbol z^{(l)}$的分布一致，比如都归一化到标准正态分布。虽然归一化操作可以应用在输入$\boldsymbol a^{(l-1)}$上，但其<strong>分布性质</strong>不如$\boldsymbol z^{(l)}$稳定。因此，<strong>在实践中归一化操作一般应用在仿射变换之后，激活函数之前</strong>。</p><p>对$\boldsymbol z^{(l)}$进行归一化，相当于<strong>每一层都进行一次数据预处理</strong>，从而加速收敛速度。但是逐层归一化需要在中间层进行操作，要求效率比较高，因此复杂度比较高的<strong>白化方法</strong>就不太合适。为了提高归一化效率，一般使用<strong>标准归一化</strong>，将净输入$\boldsymbol z^{(l)}$的<strong>每一维都归一到标准正态分布</strong>。</p>$$
\hat{\boldsymbol{z}}^{(l)}=\frac{\boldsymbol{z}^{(l)}-\mathbb{E}[\boldsymbol{z}^{(l)}]}{\sqrt{\operatorname{var}(\boldsymbol{z}^{(l)})+\epsilon}}
$$<p>其中$\mathbb{E}[\boldsymbol{z}^{(l)}]$和$\operatorname{var}(\boldsymbol{z}^{(l)})$是指当前参数下，$\boldsymbol{z}^{(l)}$的<strong>每一维在整个训练集上的期望和方差</strong>。因为目前主要的训练方法是基于小批量的随机梯度下降法，所以准确地计算的期望$\boldsymbol{z}^{(l)}$和方差是不可行的。因此，$\boldsymbol{z}^{(l)}$的<strong>期望和方差通常用当前小批量样本集的均值和方差近似估计</strong>。</p><p>给定一个包含$K$个样本的小批量样本集合，第$l$层神经元的净输入$\boldsymbol{z}^{(1, l)},\cdots,\boldsymbol{z}^{(K, l)}$的均值和方差为：</p>$$
\begin{aligned}
\boldsymbol{\mu}_{\mathcal{B}} &=\frac{1}{K} \sum_{k=1}^{K} \boldsymbol{z}^{(k, l)} \\
\boldsymbol{\sigma}_{\mathcal{B}}^{2} &=\frac{1}{K} \sum_{k=1}^{K}(\boldsymbol{z}^{(k, l)}-\boldsymbol{\mu}_{\mathcal{B}}) \odot(\boldsymbol{z}^{(k, l)}-\boldsymbol{\mu}_{\mathcal{B}})
\end{aligned}
$$<p>其中$\boldsymbol{\mu}_{\mathcal{B}}$和$\boldsymbol{\sigma}_{\mathcal{B}}^{2}$均为向量，其维度与数据的特征数相等。</p><p>对净输入$\boldsymbol{z}^{(l)}$的标准归一化会使得其取值集中到0附近，如果使用 sigmoid型激活函数时，这个取值区间刚好是接近线性变换的区间，<strong>减弱了神经网络的非线性性质</strong>。因此，为了使得归一化不对网络的表示能力造成负面影响，可以通过一个<strong>附加的缩放和平移变换改变取值区间</strong>：</p>$$
\begin{aligned}
\hat{\boldsymbol{z}}^{(l)} &=\frac{\boldsymbol{z}^{(l)}-\boldsymbol{\mu}_{\mathcal{B}}}{\sqrt{\sigma_{\mathcal{B}}^{2}+\epsilon}} \odot \gamma+\boldsymbol{\beta} \\
& \triangleq \mathrm{B} \mathrm{N}_{\boldsymbol{\gamma}, \boldsymbol{\beta}}(\boldsymbol{z}^{(l)})
\end{aligned}
$$<p>其中$\boldsymbol \gamma$和$\boldsymbol \beta$分别代表缩放和平移的参数向量。从最保守的角度考虑，可通过标准归一化的逆变换来使得归一化后的变量可以<strong>被还原为原来的值</strong>。当$\gamma=\sqrt{\sigma_{\mathcal{B}}^{2}}$且$\beta=\mu_{\mathcal{B}}$时，$\hat{\boldsymbol{z}}^{(l)}=\boldsymbol{z}^{(l)}$。批量归一化操作可以看作是一个特殊的神经层，加在每一层非线性激活函数之前，即：</p>$$
\boldsymbol{a}^{(l)}=f(\mathrm{BN}_{\gamma, \boldsymbol{\beta}}(\boldsymbol{z}^{(l)}))=f(\mathrm{BN}_{\gamma, \boldsymbol{\beta}}(W \boldsymbol{a}^{(l-1)}))
$$<h2 id=层归一化>层归一化</h2><p>批量归一化是对一个中间层的<strong>单个神经元(特征)</strong> 进行归一化操作，因此要求小批量样本的数量不能太小，否则难以计算单个神经元的统计信息。此外，如果一个神经元的净输入的分布在神经网络中是动态变化的，比如循环神经网络，那么就无法应用批量归一化操作。</p><p><strong>层归一化(layer normalization)</strong> 是和批量归一化非常类似的方法。和批量归一化不同的是，层归一化是对一个中间层的所有神经元进行归一化。</p><p>对于一个深度神经网络，令第$l$层神经元的净输入为$\boldsymbol z^{(l)}$，其均值和方差为：</p>$$
\begin{aligned}
\mu^{(l)} &=\frac{1}{n^{l}} \sum_{i=1}^{n^{l}} z_{i}^{(l)} \\
\sigma^{(l)^{2}} &=\frac{1}{n^{l}} \sum_{i=1}^{n^{l}}(z_{i}^{(l)}-\mu^{(l)})^{2}
\end{aligned}
$$<p>其中$n^l$为第$l$层神经元的数量。层归一化定义为：</p>$$
\begin{aligned}
\hat{\boldsymbol{z}}^{(l)} &=\frac{\boldsymbol{z}^{(l)}-\mu^{(l)}}{\sqrt{\sigma^{(l)^{2}}+\epsilon}} \odot \boldsymbol \gamma+\boldsymbol{\beta} \\
& \triangleq \mathrm{LN}_{\boldsymbol{\gamma}, \boldsymbol{\beta}}(\boldsymbol{z}^{(l)})
\end{aligned}
$$<p>其中$\boldsymbol \gamma$和$\boldsymbol \beta$分别代表缩放和平移的参数向量，和$\boldsymbol z^{(l)}$维数相同。</p><p>层归一化可以应用在循环神经网络中，对循环神经层进行归一化操作。假设在时刻$t$，循环神经网络的隐藏层为$\boldsymbol h_t$，其层归一化的更新为：</p>$$
\begin{aligned}
z_{t}=U \boldsymbol{h}_{t-1}+W \boldsymbol{x}_{t} \\
\boldsymbol{h}_{t}=f(\mathrm{LN}_{\gamma, \boldsymbol{\beta}}(\boldsymbol{z}_{t}))
\end{aligned}
$$<p>其中$\boldsymbol x_t$为第$t$时刻的输入，$U,W$为网络参数。在标准循环神经网络中，循环神经层的净输入一般会随着时间慢慢变大或变小，从而导致梯度爆炸或消失。而<strong>层归一化的循环神经网络可以有效地缓解这种状况</strong>。</p><p>层归一化和批量归一化整体上是十分类似的，差别在于归一化的方法不同。对于 $K$个样本的一个小批量集合$Z^{(l)}=[\boldsymbol{z}^{(1, l)} ; \cdots ; \boldsymbol{z}^{(K, l)}]$，层归一化是对矩阵$Z^{(l)}$的<strong>每一列</strong>进行归一化，而批量归一化是对<strong>每一行</strong>进行归一化。一般而言，<strong>批量归一化是一种更好的选择。当小批量样本数量比较小时，可以选择层归一化</strong>。</p><p>除了上述两种归一化方法外，还有权重归一化、局部相应归一化等多种归一化方式。</p><h1 id=超参数优化>超参数优化</h1><p>在神经网络中，除了可学习参数之外，还存在很多<strong>超参数</strong>。这些超参数对网络性能的影响也很大。不同的机器学习任务往往需要不同的超参数。常见的超参数有以下三类：(1) <strong>网络结构</strong>，包括神经元间的连接关系、层数、每层的神经元数量、激活函数的类型等。(2) <strong>优化参数</strong>，包括优化方法、学习率、小批量的样本数量等。(3) <strong>正则化系数</strong>。</p><p><strong>超参数优化(hyperparameter optimization)<strong>主要存在两方面的困难。(1) 超参数优化是一个</strong>组合优化问题</strong>，无法像一般参数那样通过梯度下降方法来优化，也没有一种通用有效的优化方法。(2) 评估一组超参数配置的<strong>时间代价非常高</strong>，从而导致一些优化方法在超参数优化中难以应用。</p><h2 id=网格搜索>网格搜索</h2><p>网格搜索(grid search)是一种通过尝试所有超参数的组合来寻址合适一组超参数配置的方法。假设总共有$K$个超参数，第$k$个超参数的可以取$m_k$个值。那么总共的配置组合数量为$m_1 \times m_2 \times \cdots \times m_K$。如果超参数是连续的，可以将超参数<strong>离散化</strong>，选择几个“经验”值。比如学习率$\alpha$，我们可以设置$α \in \{0.01, 0.1, 0.5, 1.0\}$。</p><p>一般而言，对于连续的超参数，我们<strong>不能按等间隔的方式进行离散化</strong>，需要根据超参数自身的特点进行离散化。</p><p>网格搜索根据这些超参数的不同组合分别训练一个模型，然后测试这些模型在开发集上的性能，<strong>选取一组性能最好的配置</strong>。</p><h2 id=随机搜索>随机搜索</h2><p>如果不同超参数对模型性能的影响有很大差异。<strong>有些超参数(比如正则化系数)对模型性能的影响有限</strong>，而<strong>另一些超参数(比如学习率)对模型性能影响比较大</strong>。在这种情况下，采用网格搜索会在不重要的超参数上进行不必要的尝试。一种在实践中比较有效的改进方法是<strong>对超参数进行随机组合</strong>，然后选取一个性能最好的配置，这就是<strong>随机搜索(random search)</strong>。随机搜索在实践中更容易实现，一般会比网格搜索更加有效。</p><p>网格搜索和随机搜索都没有利用不同超参数组合之间的相关性，即如果模型的超参数组合比较类似，其模型性能也是比较接近的。因此这两种搜索方式一般都比较低效。下面我们介绍两种<strong>自适应的超参数优化方法</strong>：贝叶斯优化和动态资源分配。</p><h2 id=贝叶斯优化>贝叶斯优化</h2><p><strong>贝叶斯优化(Bayesian optimization)</strong> 是一种自适应的超参数优化方法，根据当前已经试验的超参数组合来预测下一个可能带来最大收益的组合。一种比较常用的贝叶斯优化方法为<strong>时序模型优化(sequential model-based optimization, SMBO)</strong>。</p><h2 id=动态资源分配>动态资源分配</h2><p>在超参数优化中，每组超参数配置的评估代价比较高。如果我们可以在较早的阶段就估计出一组配置的效果会比较差，那么我们就可以中止这组配置的评估，将更多的资源留给其它配置。这个问题可以归结为<strong>多臂赌博机问题</strong>的一个泛化问题：<strong>最优臂问题(best-arm problem)</strong>，即在给定有限的机会次数下，如何玩这些赌博机并找到收益最大的臂。</p><p>由于目前神经网络的优化方法一般都采取随机梯度下降，因此我们可以通过一组超参数的学习曲线来预估这组超参数配置是否有希望得到比较好的结果。如果一组超参数配置的学习曲线不收敛或者收敛比较差，我们可以应用<strong>早期停止(early-stopping)<strong>策略来中止当前的训练。动态资源分配的一种有效方法是</strong>逐次减半(successive halving)方法</strong>，将超参数优化看作是一种非随机的最优臂问题。</p><h2 id=神经架构搜索>神经架构搜索</h2><p>上面介绍的超参数优化方法都是在固定(或变化比较小)的超参数空间中进行最优配置搜索，而最重要的神经网络架构一般还是需要由有经验的专家来进行设计。从某种角度来讲，深度学习使得机器学习中的“特征工程”问题转变为“网络架构工程”问题。</p><p><strong>神经架构搜索(neural architecture search, NAS)</strong> 是一个新的比较有前景的研究方向，通过神经网络来自动实现网络架构的设计。一个神经网络的架构可以用一个变长的字符串来描述。利用元学习的思想，神经架构搜索利用一个控制器来生成另一个子网络的架构描述，控制器可以由一个循环神经网络来实现。控制器的训练可以通过强化学习来完成，其奖励信号为生成的子网络在开发集上的准确率。</p><h1 id=网络正则化>网络正则化</h1><p>机器学习模型的关键是<strong>泛化问题</strong>，即<strong>在样本真实分布上的期望风险最小化</strong>。而训练数据集上的经验风险最小化和期望风险并不一致。由于神经网络的拟合能力非常强，其在训练数据上的错误率往往都可以降到非常低，甚至可以到0，从而导致过拟合。因此，如何提高神经网络的泛化能力反而成为影响模型能力的最关键因素。</p><p><strong>正则化(regularization)</strong> 是一类通过限制模型复杂度，从而避免过拟合，提高泛化能力的方法，比如引入约束、增加先验、提前停止等。</p><p>在传统的机器学习中，提高泛化能力的方法主要是限制模型复杂度，比如采用$\ell_{1}$和$\ell_{2}$正则化等方式。而在训练深度神经网络时，特别是在<strong>过度参数化(over-parameterization)</strong> 时，$\ell_{1}$和$\ell_{2}$正则化的效果往往不如浅层机器学习模型中显著，<strong>过度参数化是指模型参数的数量远远大于训练数据的数量</strong>。因此训练深度学习模型时，往往还会使用其它的正则化方法，比如数据增强、提前停止、丢弃法、集成法等。</p><h2 id=和正则化>$\ell_{1}$和$\ell_{2}$正则化</h2><p>$\ell_{1}$和$\ell_{2}$正则化是机器学习中最常用的正则化方法，通过约束参数的$\ell_{1}$和$\ell_{2}$<strong>范数</strong>来减小模型在训练数据集上的过拟合现象。 通过引入$\ell_{1}$和$\ell_{2}$正则化，优化问题可以写为：</p>$$
\theta^{*}=\underset{\theta}{\arg \min } \frac{1}{N} \sum_{n=1}^{N} \mathcal{L}(y^{(n)}, f(\boldsymbol{x}^{(n)} ; \theta))+\lambda \ell_{p}(\theta)
$$<p>其中$p$通常取值1或2，代表$\ell_{1}$范式和$\ell_{2}$范式。</p><p>带正则化的优化问题等价于下面带约束条件的优化问题：</p>$$
\theta^{*}=\underset{\theta}{\arg \min } \frac{1}{N} \sum_{n=1}^{N} \mathcal{L}(y^{(n)}, f(\boldsymbol{x}^{(n)} ; \theta)) \\
\text{subject to } \ell_{p}(\theta) \leq 1
$$<p>一种折中的正则化方法是<strong>弹性网络正则化(elastic net regularization)</strong>：</p>$$
\theta^{*}=\underset{\theta}{\arg \min } \frac{1}{N} \sum_{n=1}^{N} \mathcal{L}(y^{(n)}, f(\boldsymbol{x}^{(n)} ; \theta))+\lambda_{1} \ell_{1}(\theta)+\lambda_{2} \ell_{2}(\theta)
$$<p>其中$\lambda_1$和$\lambda_2$分别为两个正则化系数。</p><h2 id=权重衰减>权重衰减</h2><p><strong>权重衰减(weight decay)</strong> 也是一种有效的正则化方法，<strong>在每次参数更新时，引入一个衰减系数</strong>：</p>$$
\theta_{t} \leftarrow(1-w) \theta_{t-1}-\alpha \mathbf{g}_{t}
$$<p>其中$\mathbf{g}_{t}$为第$t$更新的梯度，$\alpha$为学习率，$w$为<strong>权重衰减系数</strong>，一般取值比较小，比如0*.*0005。在标准的随机梯度下降中，权重衰减正则化和正则化的$\ell_2$效果相同。因此，权重衰减在一些深度学习框架中通过$\ell_2$正则化来实现。但是，在<strong>较为复杂的优化方法(比如 Adam)</strong> 中，权重衰减和$\ell_2$正则化并不等价。</p><h2 id=提前停止>提前停止</h2><p><strong>提前停止(early stop)</strong> 对于深度神经网络来说是一种简单有效的正则化方法。由于深度神经网络的拟合能力非常强，因此比较容易在训练集上过拟合。在使用梯度下降法进行优化时，我们可以使用一个和训练集独立的样本集合，称为<strong>验证集(validation set)</strong>，并<strong>用验证集上的错误来代替期望错误</strong>。<strong>当验证集上的错误率不再下降，就停止迭代</strong>。 然而在实际操作中，验证集上的错误率变化曲线<strong>并不一定是平衡曲线，很可能是先升高再降低</strong>。因此，提前停止的具体停止标准需要根据实际任务进行优化。</p><h2 id=丢弃法>丢弃法</h2><p>当训练一个深度神经网络时，我们可以随机丢弃一部分神经元并同时丢弃其对应的连接边来避免过拟合，这种方法称为<strong>丢弃法(dropout)</strong>。每次选择丢弃的神经元是随机的。最简单的方法是设置一个固定的概率$p$。对每一个神经元都以概率$p$来判定要不要保留。对于一个神经层$\boldsymbol y = f(W \boldsymbol x+\boldsymbol b)$，我们可以引入一个丢弃函数$d(\cdot)$，使得神经网络的运算过程变为$\boldsymbol y = f(W d(\boldsymbol x)+\boldsymbol b)$。丢弃函数的定义如下：</p>$$
d(\boldsymbol{x})=\left\{\begin{array}{ll}
\boldsymbol{m} \odot \boldsymbol{x} & \text { when training } \\
p \boldsymbol{x} & \text { when testing }
\end{array}\right.
$$<p>其中$\boldsymbol{m} \in\{0,1\}^{d}$为<strong>丢弃掩码(dropout mask)</strong>，通过以概率为$p$的<strong>伯努利分布</strong>随机生成。在<strong>训练时</strong>，激活神经元的平均数量为原来的$p$倍。而在测试时，所有的神经元都是可以激活的，这会造成训练和测试时网络的输出不一致。为了缓解这个问题，在<strong>测试时</strong>需要将神经层的输入$\boldsymbol x$乘以$p$，也相当于<strong>把不同的神经网络做了平均</strong>。丢弃率$p$可以通过验证集来选取一个最优的值。一般来讲，对于隐藏层的神经元，其丢弃率$p=0.5$时效果最好，这对大部分的网络和任务都比较有效。当$p=0.5$时，<strong>在训练时有一半的神经元被丢弃，只剩余一半的神经元是可以激活的，随机生成的网络结构最具多样性</strong>。对于<strong>输入层的神经元</strong>，其丢弃率通常设为更接近1的数，使得输入变化不大。对输入层神经元进行丢弃时，<strong>相当于给数据增加噪声，以此来提高网络的鲁棒性</strong>。</p><div align=center><img src=/Kimages/3/image-20200806101947541.png style=zoom:30%></div><p>Dropout一般是针对神经元进行随机丢弃，但是也可以扩展到<strong>对神经元之间的连接进行随机丢弃</strong>，或<strong>每一层进行随机丢弃</strong>。Dropout有以下两种解释：</p><p>(1) <strong>集成学习的解释</strong>：每做一次丢弃，相当于从原始的网络中采样得到一个子网络。如果一个神经网络有$n$个神经元，那么总共可以采样出$2^n$个子网络。每次迭代都相当于训练一个不同的子网络，这些子网络共享原始网络的参数。那么，最终的网络可以近似看作<strong>集成了指数级个不同网络的组合模型</strong>。</p><p>(2) <strong>贝叶斯学习的解释</strong>：丢弃法也可以解释为一种贝叶斯学习的近似。 用$y = f(\boldsymbol x; \theta)$来表示要学习的神经网络，贝叶斯学习是假设参数为$\theta$随机向量，并且先验分布为$q(\theta)$，贝叶斯方法的预测为：</p>$$
\begin{aligned}
\mathbb{E}_{q(\theta)}[y] &=\int_{q} f(\boldsymbol{x} ; \theta) q(\theta) d \theta \\
& \approx \frac{1}{M} \sum_{m=1}^{M} f(\boldsymbol{x}, \theta_{m})
\end{aligned}
$$<p>其中$f(\boldsymbol{x}, \theta_{m})$为为第$m$次应用丢弃方法后的网络，其参数$\theta_m$为对全部参数$\theta$的一次<strong>采样</strong>。</p><h2 id=数据增强>数据增强</h2><p>深度神经网络一般都需要大量的训练数据才能获得比较理想的效果。在数据量有限的情况下，可以通过<strong>数据增强(data augmentation</strong>)来增加数据量，提高模型鲁棒性，避免过拟合。<strong>目前，数据增强还主要应用在图像数据上，在文本等其它类型的数据上还没有太好的方法</strong>。</p><p>图像数据的增强主要是通过算法对图像进行转变，引入噪声等方法来增加数据的多样性。增强的方法主要有几种：</p><p>(1) <strong>旋转(rotation)</strong>：将图像按顺时针或逆时针方向随机旋转一定角度。</p><p>(2) <strong>翻转(flip)</strong>：将图像沿水平或垂直方法随机翻转一定角度。</p><p>(3) <strong>缩放(zoom in/out)</strong>：将图像放大或缩小一定比例。</p><p>(4) <strong>平移(shift)</strong>：将图像沿水平或垂直方法平移一定步长。</p><p>(5) <strong>加噪声(noise)</strong>：加入随机噪声。</p><h2 id=标签平滑>标签平滑</h2><p>在数据增强中，我们可以给样本特征加入随机噪声来避免过拟合。同样，我们也可以给样本的标签引入一定的噪声。假设训练数据集中有一些样本的标签是<strong>被错误标注</strong>的，那么最小化这些样本上的损失函数会导致过拟合。一种改善的正则化方法是<strong>标签平滑(label smoothing)</strong>，即在输出标签中添加噪声来避免模型过拟合。</p><p>通常样本标签为：</p>$$
\boldsymbol{y}=[0, \cdots, 0,1,0, \cdots, 0]^{\mathrm{T}}
$$<p>这种标签可以看作是<strong>硬目标(hard target)</strong>。如果使用<strong>softmax分类器</strong>并使用<strong>交叉熵损失函数</strong>，最小化损失函数会使得正确类和其它类的权重差异很大。根据softmax函数的性质可知，如果要使得某一类的输出概率接近于1，其未归一化的得分需要远大于其它类的得分，可能会导致其权重越来越大，并导致过拟合。此外，如果样本标签是<strong>错误的</strong>，会<strong>导致更严重的过拟合现象</strong>。为改善这种情况，我们可以引入噪声对标签进行平滑，平滑后的标签为：</p>$$
\tilde{\boldsymbol{y}}=\left[\frac{\epsilon}{K-1}, \cdots, \frac{\epsilon}{K-1}, 1-\epsilon, \frac{\epsilon}{K-1}, \cdots, \frac{\epsilon}{K-1}\right]^{\mathrm{T}}
$$<p>其中$K$为标签数量，这种标签可以看作是<strong>软目标(soft target)</strong>。标签平滑可以<strong>避免模型的输出过拟合到硬目标上</strong>，并且通常不会损害其分类能力。</p><h1 id=tensorflow实现神经网络并比较不同的优化器的优化效果>Tensorflow实现神经网络并比较不同的优化器的优化效果</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> tensorflow <span style=color:#ff79c6>as</span> tf
</span></span><span style=display:flex><span><span style=color:#ff79c6>import</span> matplotlib.pyplot <span style=color:#ff79c6>as</span> plt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 下载MNIST数据并进行归一化</span>
</span></span><span style=display:flex><span>mnist <span style=color:#ff79c6>=</span> tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>datasets<span style=color:#ff79c6>.</span>mnist
</span></span><span style=display:flex><span>(X_train, y_train), (X_test, y_test) <span style=color:#ff79c6>=</span> mnist<span style=color:#ff79c6>.</span>load_data()
</span></span><span style=display:flex><span>X_train, X_test <span style=color:#ff79c6>=</span> X_train <span style=color:#ff79c6>/</span> <span style=color:#bd93f9>255.0</span>, X_test <span style=color:#ff79c6>/</span> <span style=color:#bd93f9>255.0</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(X_train<span style=color:#ff79c6>.</span>shape, X_test<span style=color:#ff79c6>.</span>shape, y_train<span style=color:#ff79c6>.</span>shape, y_test<span style=color:#ff79c6>.</span>shape)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 定义网络结构</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>define_network</span>():
</span></span><span style=display:flex><span>    neural_network <span style=color:#ff79c6>=</span> tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>models<span style=color:#ff79c6>.</span>Sequential([
</span></span><span style=display:flex><span>        tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>layers<span style=color:#ff79c6>.</span>Input(shape<span style=color:#ff79c6>=</span>(<span style=color:#bd93f9>28</span>, <span style=color:#bd93f9>28</span>)),
</span></span><span style=display:flex><span>        tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>layers<span style=color:#ff79c6>.</span>Flatten(),
</span></span><span style=display:flex><span>        tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>layers<span style=color:#ff79c6>.</span>Dense(<span style=color:#bd93f9>512</span>, activation<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;relu&#39;</span>),
</span></span><span style=display:flex><span>        tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>layers<span style=color:#ff79c6>.</span>Dense(<span style=color:#bd93f9>128</span>, activation<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;relu&#39;</span>),
</span></span><span style=display:flex><span>        tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>layers<span style=color:#ff79c6>.</span>Dense(<span style=color:#bd93f9>10</span>, activation<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;softmax&#39;</span>)
</span></span><span style=display:flex><span>    ])
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> neural_network
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 定义多个网络，后期使用不同的优化器进行优化</span>
</span></span><span style=display:flex><span>nn_sgd <span style=color:#ff79c6>=</span> define_network()
</span></span><span style=display:flex><span>nn_adagrad <span style=color:#ff79c6>=</span> define_network()
</span></span><span style=display:flex><span>nn_adam <span style=color:#ff79c6>=</span> define_network()
</span></span><span style=display:flex><span>nn_rms <span style=color:#ff79c6>=</span> define_network()
</span></span><span style=display:flex><span>nn_delta <span style=color:#ff79c6>=</span> define_network()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 配置并训练优化方式不同的模型</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># SGD</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#39;SGD&#39;</span>)
</span></span><span style=display:flex><span>nn_sgd<span style=color:#ff79c6>.</span>compile(optimizer<span style=color:#ff79c6>=</span>tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>optimizers<span style=color:#ff79c6>.</span>SGD(), loss<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;sparse_categorical_crossentropy&#39;</span>, metrics<span style=color:#ff79c6>=</span>[<span style=color:#f1fa8c>&#39;accuracy&#39;</span>])
</span></span><span style=display:flex><span>history_sgd <span style=color:#ff79c6>=</span> nn_sgd<span style=color:#ff79c6>.</span>fit(X_train, y_train, batch_size<span style=color:#ff79c6>=</span><span style=color:#bd93f9>64</span>, epochs<span style=color:#ff79c6>=</span><span style=color:#bd93f9>50</span>, validation_data<span style=color:#ff79c6>=</span>(X_test, y_test), verbose<span style=color:#ff79c6>=</span><span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># AdaGrad</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#39;AdaGrad&#39;</span>)
</span></span><span style=display:flex><span>nn_adagrad<span style=color:#ff79c6>.</span>compile(optimizer<span style=color:#ff79c6>=</span>tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>optimizers<span style=color:#ff79c6>.</span>Adagrad(), loss<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;sparse_categorical_crossentropy&#39;</span>,
</span></span><span style=display:flex><span>                   metrics<span style=color:#ff79c6>=</span>[<span style=color:#f1fa8c>&#39;accuracy&#39;</span>])
</span></span><span style=display:flex><span>history_adagrad <span style=color:#ff79c6>=</span> nn_adagrad<span style=color:#ff79c6>.</span>fit(X_train, y_train, batch_size<span style=color:#ff79c6>=</span><span style=color:#bd93f9>64</span>, epochs<span style=color:#ff79c6>=</span><span style=color:#bd93f9>50</span>, validation_data<span style=color:#ff79c6>=</span>(X_test, y_test),
</span></span><span style=display:flex><span>                                 verbose<span style=color:#ff79c6>=</span><span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># Adam</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#39;Adam&#39;</span>)
</span></span><span style=display:flex><span>nn_adam<span style=color:#ff79c6>.</span>compile(optimizer<span style=color:#ff79c6>=</span>tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>optimizers<span style=color:#ff79c6>.</span>Adam(), loss<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;sparse_categorical_crossentropy&#39;</span>, metrics<span style=color:#ff79c6>=</span>[<span style=color:#f1fa8c>&#39;accuracy&#39;</span>])
</span></span><span style=display:flex><span>history_adam <span style=color:#ff79c6>=</span> nn_adam<span style=color:#ff79c6>.</span>fit(X_train, y_train, batch_size<span style=color:#ff79c6>=</span><span style=color:#bd93f9>64</span>, epochs<span style=color:#ff79c6>=</span><span style=color:#bd93f9>50</span>, validation_data<span style=color:#ff79c6>=</span>(X_test, y_test), verbose<span style=color:#ff79c6>=</span><span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># RMSprop</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#39;RMSprop&#39;</span>)
</span></span><span style=display:flex><span>nn_rms<span style=color:#ff79c6>.</span>compile(optimizer<span style=color:#ff79c6>=</span>tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>optimizers<span style=color:#ff79c6>.</span>RMSprop(), loss<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;sparse_categorical_crossentropy&#39;</span>, metrics<span style=color:#ff79c6>=</span>[<span style=color:#f1fa8c>&#39;accuracy&#39;</span>])
</span></span><span style=display:flex><span>history_rms <span style=color:#ff79c6>=</span> nn_rms<span style=color:#ff79c6>.</span>fit(X_train, y_train, batch_size<span style=color:#ff79c6>=</span><span style=color:#bd93f9>64</span>, epochs<span style=color:#ff79c6>=</span><span style=color:#bd93f9>50</span>, validation_data<span style=color:#ff79c6>=</span>(X_test, y_test), verbose<span style=color:#ff79c6>=</span><span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># AdaDelta</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#39;AdaDelta&#39;</span>)
</span></span><span style=display:flex><span>nn_delta<span style=color:#ff79c6>.</span>compile(optimizer<span style=color:#ff79c6>=</span>tf<span style=color:#ff79c6>.</span>keras<span style=color:#ff79c6>.</span>optimizers<span style=color:#ff79c6>.</span>Adadelta(), loss<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;sparse_categorical_crossentropy&#39;</span>, metrics<span style=color:#ff79c6>=</span>[<span style=color:#f1fa8c>&#39;accuracy&#39;</span>])
</span></span><span style=display:flex><span>history_delta <span style=color:#ff79c6>=</span> nn_delta<span style=color:#ff79c6>.</span>fit(X_train, y_train, batch_size<span style=color:#ff79c6>=</span><span style=color:#bd93f9>64</span>, epochs<span style=color:#ff79c6>=</span><span style=color:#bd93f9>50</span>, validation_data<span style=color:#ff79c6>=</span>(X_test, y_test), verbose<span style=color:#ff79c6>=</span><span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 绘制不同优化器的优化过程</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># loss</span>
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>subplot(<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>plot(history_sgd<span style=color:#ff79c6>.</span>history[<span style=color:#f1fa8c>&#39;loss&#39;</span>], label<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;SGD&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>plot(history_adagrad<span style=color:#ff79c6>.</span>history[<span style=color:#f1fa8c>&#39;loss&#39;</span>], label<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;AdaGrad&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>plot(history_adam<span style=color:#ff79c6>.</span>history[<span style=color:#f1fa8c>&#39;loss&#39;</span>], label<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;Adam&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>plot(history_rms<span style=color:#ff79c6>.</span>history[<span style=color:#f1fa8c>&#39;loss&#39;</span>], label<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;RMSprop&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>plot(history_delta<span style=color:#ff79c6>.</span>history[<span style=color:#f1fa8c>&#39;loss&#39;</span>], label<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;AdaDelta&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>legend()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># accuracy</span>
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>subplot(<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>plot(history_sgd<span style=color:#ff79c6>.</span>history[<span style=color:#f1fa8c>&#39;accuracy&#39;</span>], label<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;SGD&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>plot(history_adagrad<span style=color:#ff79c6>.</span>history[<span style=color:#f1fa8c>&#39;accuracy&#39;</span>], label<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;Adagrad&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>plot(history_adam<span style=color:#ff79c6>.</span>history[<span style=color:#f1fa8c>&#39;accuracy&#39;</span>], label<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;Adam&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>plot(history_rms<span style=color:#ff79c6>.</span>history[<span style=color:#f1fa8c>&#39;accuracy&#39;</span>], label<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;RMSprop&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>plot(history_delta<span style=color:#ff79c6>.</span>history[<span style=color:#f1fa8c>&#39;accuracy&#39;</span>], label<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#39;AdaDelta&#39;</span>)
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>legend()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plt<span style=color:#ff79c6>.</span>show()
</span></span></code></pre></div><h1 id=参考资料>参考资料</h1><ul><li>邱锡鹏. 神经网络与深度学习. 北京: 机械工业出版社, 2020.</li><li>Srivastava N, Hinton G, Krizhevsky A, et al. Dropout: a simple way to prevent neural networks from overfitting. The journal of machine learning research, 2014, 15(1): 1929-1958.</li><li>神经网络的优化算法：https://zhuanlan.zhihu.com/p/27449596</li></ul><hr><ul class=pager><li class=previous><a href=/post/4-dl/dl4-%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/ data-toggle=tooltip data-placement=top title=深度学习：循环神经网络>&larr;
Previous Post</a></li><li class=next><a href=/post/4-dl/dl6-%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/ data-toggle=tooltip data-placement=top title=深度学习：自编码器>Next
Post &rarr;</a></li></ul><script src=https://giscus.app/client.js data-repo=XiangdiWu/XiangdiWu.github.io data-repo-id=R_kgDOP0pDUQ data-category=Announcements data-category-id=DIC_kwDOP0pDUc4CvwjG data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=light data-lang=zh-CN crossorigin=anonymous async></script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/deep-learning title="deep learning">deep learning
</a><a href=/tags/machine-learning title="machine learning">machine learning
</a><a href=/tags/math title=math>math
</a><a href=/tags/model title=model>model
</a><a href=/tags/nlp title=nlp>nlp
</a><a href=/tags/quant title=quant>quant</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://www.factorwar.com/data/factor-models/>GetAstockFactors</a></li><li><a target=_blank href=https://datawhalechina.github.io/whale-quant/#/>Whale-Quant</a></li></ul></section></div></div></div></article><script type=module>  
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs'; 
    mermaid.initialize({ startOnLoad: true });  
</script><script>Array.from(document.getElementsByClassName("language-mermaid")).forEach(e=>{e.parentElement.outerHTML=`<div class="mermaid">${e.innerHTML}</div>`})</script><style>.mermaid svg{display:block;margin:auto}</style><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:bernicewu2000@outlook.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat_qrcode.jpg><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/xiangdiwu><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="Xiangdi Blog"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; Xiangdi Blog 2025</p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){n=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),t=$(this).text(),i=$('<a href="'+o+'" rel="nofollow" title="'+t+'">'+t+"</a>"),s=$('<li class="'+n+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script><style>.markmap>svg{width:100%;height:300px}</style><script>window.markmap={autoLoader:{manual:!0,onReady(){const{autoLoader:e,builtInPlugins:t}=window.markmap;e.transformPlugins=t.filter(e=>e.name!=="prism")}}}</script><script src=https://cdn.jsdelivr.net/npm/markmap-autoloader></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css integrity="sha512-r2+FkHzf1u0+SQbZOoIz2RxWOIWfdEzRuYybGjzKq18jG9zaSfEy9s3+jMqG/zPtRor/q4qaUCYQpmSjTw8M+g==" crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js integrity="sha512-INps9zQ2GUEMCQD7xiZQbGUVnqnzEvlynVy6eqcTcHN4+aQiLo9/uaQqckDpdJ8Zm3M0QBs+Pktg4pz0kEklUg==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/mhchem.min.js integrity="sha512-mxjNw/u1lIsFC09k/unscDRY3ofIYPVFbWkP8slrePcS36ht4d/OZ8rRu5yddB2uiqajhTcLD8+jupOWuYPebg==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js integrity="sha512-YJVxTjqttjsU3cSvaTRqsSl0wbRgZUNF+NGGCgto/MUbIvaLdXQzGTCQu4CvyJZbZctgflVB0PXw9LLmTWm5/w==" crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"},{display:!0,left:"\\[",right:"\\]"}],errorcolor:"#CD5C5C",throwonerror:!1})'></script></body></html>