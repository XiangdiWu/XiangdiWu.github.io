<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="Xiangdi Blog"><meta property="og:type" content="article"><meta property="og:image" con ’tent=/img/background.webp><meta property="twitter:image" content="/img/background.webp"><meta name=title content="量化编程基础： Python "><meta property="og:title" content="量化编程基础： Python "><meta property="twitter:title" content="量化编程基础： Python "><meta name=description content="本文介绍了量化分析中最常用的 Python 数据类型和结构，以及常用的编程逻辑。"><meta property="og:description" content="本文介绍了量化分析中最常用的 Python 数据类型和结构，以及常用的编程逻辑。"><meta property="twitter:description" content="本文介绍了量化分析中最常用的 Python 数据类型和结构，以及常用的编程逻辑。"><meta property="twitter:card" content="summary"><meta property="og:url" content="https://xiangdiwu.github.io/2021/07/06/quant-python-basics/"><meta name=keyword content="吴湘菂, WuXiangdi, XiangdiWu, 吴湘菂的网络日志, 吴湘菂的博客, Xiangdi Blog, 博客, 个人网站, Quant, 量化投资, 金融, 投资, 理财, 股票, 期货, 基金, 期权, 外汇, 比特币"><link rel="shortcut icon" href=/img/favicon.ico><title>量化编程基础： Python -吴湘菂的博客 | Xiangdi Blog</title><link rel=canonical href=/2021/07/06/quant-python-basics/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.min.css><link rel=stylesheet href=/css/font-awesome.all.min.css><script src=/js/jquery.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/hux-blog.min.js></script><script src=/js/lazysizes.min.js></script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-R757MDJ6Y6"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-R757MDJ6Y6")}</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"\\[",right:"\\]",display:!0},{left:"$$",right:"$$",display:!0},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1})})</script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type=text/javascript></script><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span>
</button>
<a class=navbar-brand href=/>Xiangdi Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/quant/>quant</a></li><li><a href=/categories/reading/>reading</a></li><li><a href=/categories/tech/>tech</a></li><li><a href=/archive//>ARCHIVE</a></li><li><a href=/vibe//>Vibe</a></li><li><a href=/travel//>TRAVEL</a></li><li><a href=/about//>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/background.webp)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/quant title=Quant>Quant</a></div><h1>量化编程基础： Python</h1><h2 class=subheading>Quant Python Basics</h2><span class=meta>Posted by
Xiangdi Wu
on
Monday, July 5, 2021</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><h2 id=一python-基本数据类型>一、Python 基本数据类型</h2><p>Python 的三大基本数据类型，是量化分析的起点：</p><h3 id=整数int>整数（int）</h3><p>整数是没有小数部分的数字，在金融中常用于记录 “数量”—— 比如股票的持仓股数（1000 股）、交易日天数（252 天 / 年）、订单编号（10086）等。</p><p><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># 记录持仓股数</span>
</span></span><span style=display:flex><span>holdings <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1000</span>  
</span></span><span style=display:flex><span><span style=color:#6272a4># 计算一年交易日（A股约252天）</span>
</span></span><span style=display:flex><span>trading_days <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>252</span>
</span></span></code></pre></div><p>整数的运算非常直接（加减乘除、取余等），比如计算 “持仓 1000 股，每股涨 2 元，总收益是多少”：<code>profit = 1000 * 2</code>，结果为 2000（元）。</p><h3 id=浮点数float>浮点数（float）</h3><p>浮点数是带小数的数字，金融中几乎所有 “连续型数据” 都用它表示：股票价格（30.5 元）、收益率（5.2%）、手续费率（0.03%）等。</p><p><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># 股票价格</span>
</span></span><span style=display:flex><span>stock_price <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>30.5</span>  
</span></span><span style=display:flex><span><span style=color:#6272a4># 单日收益率（5.2%）</span>
</span></span><span style=display:flex><span>daily_return <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0.052</span>  
</span></span><span style=display:flex><span><span style=color:#6272a4># 手续费率（万分之三）</span>
</span></span><span style=display:flex><span>fee_rate <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0.0003</span>
</span></span></code></pre></div><p>浮点数的运算需要注意精度（避免小数位数过多导致误差），比如计算 “1000 股，每股 30.5 元，总市值”：<code>market_value = 1000 * 30.5</code>，结果为 30500.0（元）。</p><h3 id=字符串str>字符串（str）</h3><p>字符串是由字符组成的文本，用于给金融数据 “打标签”—— 比如股票代码（“600036.SH”）、公司名称（“招商银行”）、日期（“2023-10-01”）等。</p><p><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># 股票代码（沪市用.SH，深市用.SZ）</span>
</span></span><span style=display:flex><span>stock_code <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;600036.SH&#34;</span>  
</span></span><span style=display:flex><span><span style=color:#6272a4># 交易日期</span>
</span></span><span style=display:flex><span>trade_date <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;2023-10-01&#34;</span>  
</span></span><span style=display:flex><span><span style=color:#6272a4># 策略名称</span>
</span></span><span style=display:flex><span>strategy_name <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;双均线策略&#34;</span>
</span></span></code></pre></div><p>字符串的核心作用是 “标识”，比如通过股票代码区分不同标的，通过日期筛选特定时间段的数据。在量化中，常需要将字符串转换为其他类型（如日期字符串转成时间格式），方便后续计算。</p><h2 id=二python-金融数据结构>二、Python 金融数据结构</h2><p>金融数据往往不是孤立的（比如一只股票的多日价格、多只股票的持仓信息），需要用 “数据结构” 来有序存储。以下 5 种结构，是量化中最常用的 “整理工具”：</p><h3 id=列表list>列表（List）</h3><p>列表是 Python 中最基础的 “有序集合”，可以存放多个数据（类型可混合），适合记录 “按顺序排列的数据”—— 比如一只股票的每日收盘价、一个策略的多笔交易记录。</p><p><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># 某股票一周的收盘价（周一到周五）</span>
</span></span><span style=display:flex><span>close_prices <span style=color:#ff79c6>=</span> [<span style=color:#bd93f9>30.5</span>, <span style=color:#bd93f9>31.2</span>, <span style=color:#bd93f9>30.8</span>, <span style=color:#bd93f9>31.5</span>, <span style=color:#bd93f9>32.0</span>]  
</span></span><span style=display:flex><span><span style=color:#6272a4># 一笔交易的信息（股票代码、日期、买卖方向、数量）</span>
</span></span><span style=display:flex><span>trade_record <span style=color:#ff79c6>=</span> [<span style=color:#f1fa8c>&#34;600036.SH&#34;</span>, <span style=color:#f1fa8c>&#34;2023-10-01&#34;</span>, <span style=color:#f1fa8c>&#34;买入&#34;</span>, <span style=color:#bd93f9>1000</span>]
</span></span></code></pre></div><p>列表的优势是 “可修改、可索引”：比如想取周三的收盘价（第 3 个元素，索引从 0 开始），直接用<code>close_prices[2]</code>即可得到 30.8；想添加周六的收盘价，用<code>close_prices.append(32.2)</code>即可。</p><h3 id=字典dictionary>字典（Dictionary）</h3><p>字典是 “键值对” 的集合（键 = 标签，值 = 数据），适合存储 “有明确对应关系的数据”—— 比如一只股票的基本信息（代码、名称、行业）、一个因子的计算参数（窗口大小、阈值）。</p><p><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># 股票基本信息（键：属性名，值：属性值）</span>
</span></span><span style=display:flex><span>stock_info <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;code&#34;</span>: <span style=color:#f1fa8c>&#34;600036.SH&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;name&#34;</span>: <span style=color:#f1fa8c>&#34;招商银行&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;industry&#34;</span>: <span style=color:#f1fa8c>&#34;银行&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;market_cap&#34;</span>: <span style=color:#bd93f9>9000</span>  <span style=color:#6272a4># 市值（亿元）</span>
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span><span style=color:#6272a4># 因子参数（如计算10日动量因子）</span>
</span></span><span style=display:flex><span>momentum_params <span style=color:#ff79c6>=</span> {<span style=color:#f1fa8c>&#34;window&#34;</span>: <span style=color:#bd93f9>10</span>, <span style=color:#f1fa8c>&#34;threshold&#34;</span>: <span style=color:#bd93f9>0.05</span>}
</span></span></code></pre></div><p>字典的核心是 “通过键快速取值”：比如想获取股票行业，直接用<code>stock_info["industry"]</code>即可得到 “银行”，无需记住顺序，比列表更直观。</p><h3 id=集合set>集合（Set）</h3><p>集合是 “无序且唯一” 的元素集合，适合 “去重” 和 “关系运算”—— 比如筛选股票池（去除重复标的）、计算两个行业的交集（同时属于金融和消费的股票）。</p><p><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># 原始股票池（含重复标的）</span>
</span></span><span style=display:flex><span>raw_stocks <span style=color:#ff79c6>=</span> {<span style=color:#f1fa8c>&#34;600036.SH&#34;</span>, <span style=color:#f1fa8c>&#34;000858.SZ&#34;</span>, <span style=color:#f1fa8c>&#34;600036.SH&#34;</span>, <span style=color:#f1fa8c>&#34;601318.SH&#34;</span>}  
</span></span><span style=display:flex><span><span style=color:#6272a4># 去重后的股票池（自动保留唯一值）</span>
</span></span><span style=display:flex><span>unique_stocks <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>set</span>(raw_stocks)  <span style=color:#6272a4># 结果：{&#34;600036.SH&#34;, &#34;000858.SZ&#34;, &#34;601318.SH&#34;}  </span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 金融行业股票池</span>
</span></span><span style=display:flex><span>finance_stocks <span style=color:#ff79c6>=</span> {<span style=color:#f1fa8c>&#34;600036.SH&#34;</span>, <span style=color:#f1fa8c>&#34;601318.SH&#34;</span>, <span style=color:#f1fa8c>&#34;600016.SH&#34;</span>}  
</span></span><span style=display:flex><span><span style=color:#6272a4># 消费行业股票池</span>
</span></span><span style=display:flex><span>consumption_stocks <span style=color:#ff79c6>=</span> {<span style=color:#f1fa8c>&#34;000858.SZ&#34;</span>, <span style=color:#f1fa8c>&#34;600036.SH&#34;</span>, <span style=color:#f1fa8c>&#34;002594.SZ&#34;</span>}  
</span></span><span style=display:flex><span><span style=color:#6272a4># 同时属于两个行业的股票（交集）</span>
</span></span><span style=display:flex><span>intersection <span style=color:#ff79c6>=</span> finance_stocks <span style=color:#ff79c6>&amp;</span> consumption_stocks  <span style=color:#6272a4># 结果：{&#34;600036.SH&#34;}</span>
</span></span></code></pre></div><p>在量化中，集合常用于清洗数据（比如去除重复的交易日）或快速筛选标的（比如找出同时满足多个条件的股票）。</p><h3 id=栈stack>栈（Stack）</h3><p>栈是一种 “后进先出”（LIFO）的结构，就像叠盘子 —— 最后放的盘子最先被拿走。在金融中，适合记录 “需要按逆序处理的数据”，比如一笔订单的拆分记录（最后拆分的子订单先成交）、策略的止损信号（最新信号优先生效）。</p><p><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># 用列表模拟栈（append()入栈，pop()出栈）</span>
</span></span><span style=display:flex><span>order_stack <span style=color:#ff79c6>=</span> []  
</span></span><span style=display:flex><span><span style=color:#6272a4># 拆分3笔子订单（按时间顺序入栈）</span>
</span></span><span style=display:flex><span>order_stack<span style=color:#ff79c6>.</span>append(<span style=color:#f1fa8c>&#34;子订单1：买入200股&#34;</span>)  
</span></span><span style=display:flex><span>order_stack<span style=color:#ff79c6>.</span>append(<span style=color:#f1fa8c>&#34;子订单2：买入300股&#34;</span>)  
</span></span><span style=display:flex><span>order_stack<span style=color:#ff79c6>.</span>append(<span style=color:#f1fa8c>&#34;子订单3：买入500股&#34;</span>)  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 出栈（最后入栈的先处理）</span>
</span></span><span style=display:flex><span>last_order <span style=color:#ff79c6>=</span> order_stack<span style=color:#ff79c6>.</span>pop()  <span style=color:#6272a4># 结果：&#34;子订单3：买入500股&#34;</span>
</span></span></code></pre></div><p>栈的核心是 “逆序处理”，比如在回测中，若一笔订单分多次成交，需要按成交顺序的逆序撤销（最新成交的先撤销），避免数据混乱。</p><h3 id=队列queue>队列（Queue）</h3><p>队列是 “先进先出”（FIFO）的结构，就像排队买票 —— 先到的人先处理。在量化中，适合处理 “按顺序生成的数据流”，比如实时行情的接收（先到的行情先处理）、多因子的计算队列（按优先级依次计算）。</p><p><strong>示例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># 用collections.deque模拟队列（append()入队，popleft()出队）</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>from</span> collections <span style=color:#ff79c6>import</span> deque  
</span></span><span style=display:flex><span>market_data_queue <span style=color:#ff79c6>=</span> deque()  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 接收实时行情（按时间顺序入队）</span>
</span></span><span style=display:flex><span>market_data_queue<span style=color:#ff79c6>.</span>append(<span style=color:#f1fa8c>&#34;9:30 行情：600036.SH 30.5元&#34;</span>)  
</span></span><span style=display:flex><span>market_data_queue<span style=color:#ff79c6>.</span>append(<span style=color:#f1fa8c>&#34;9:31 行情：600036.SH 30.6元&#34;</span>)  
</span></span><span style=display:flex><span>market_data_queue<span style=color:#ff79c6>.</span>append(<span style=color:#f1fa8c>&#34;9:32 行情：600036.SH 30.4元&#34;</span>)  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 出队（先到的先处理）</span>
</span></span><span style=display:flex><span>first_data <span style=color:#ff79c6>=</span> market_data_queue<span style=color:#ff79c6>.</span>popleft()  <span style=color:#6272a4># 结果：&#34;9:30 行情：600036.SH 30.5元&#34;</span>
</span></span></code></pre></div><p>队列的核心是 “顺序处理”，确保数据按生成时间依次被处理，避免行情错乱（比如用 9:32 的行情计算 9:30 的因子）。</p><h2 id=三python-编程基础>三、Python 编程基础</h2><p>掌握了数据类型和结构后，还需要用 “编程逻辑” 将它们串联起来，实现具体功能。以下是量化中最核心的编程基础：</p><h3 id=函数封装重复操作的-模块>函数：封装重复操作的 “模块”</h3><p>函数是 “可重复调用的代码块”，用于封装常用操作（如计算收益率、筛选因子），避免重复写代码。在量化中，几乎所有核心逻辑（如因子计算、策略信号生成）都会封装成函数。</p><p><strong>示例</strong>：计算股票的日收益率</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>calculate_daily_return</span>(close_prices):
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    计算日收益率：(今日收盘价 - 昨日收盘价) / 昨日收盘价
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    参数：close_prices - 收盘价列表（按时间顺序）
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    返回：收益率列表（长度比收盘价少1）
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    returns <span style=color:#ff79c6>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#bd93f9>1</span>, <span style=color:#8be9fd;font-style:italic>len</span>(close_prices)):
</span></span><span style=display:flex><span>        ret <span style=color:#ff79c6>=</span> (close_prices[i] <span style=color:#ff79c6>-</span> close_prices[i<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>]) <span style=color:#ff79c6>/</span> close_prices[i<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>]
</span></span><span style=display:flex><span>        returns<span style=color:#ff79c6>.</span>append(ret)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> returns
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 调用函数</span>
</span></span><span style=display:flex><span>close <span style=color:#ff79c6>=</span> [<span style=color:#bd93f9>30.5</span>, <span style=color:#bd93f9>31.2</span>, <span style=color:#bd93f9>30.8</span>, <span style=color:#bd93f9>31.5</span>, <span style=color:#bd93f9>32.0</span>]
</span></span><span style=display:flex><span>daily_returns <span style=color:#ff79c6>=</span> calculate_daily_return(close)  
</span></span><span style=display:flex><span><span style=color:#6272a4># 结果：[0.02295, -0.01282, 0.02273, 0.01587]（保留5位小数）</span>
</span></span></code></pre></div><h3 id=条件语句if-else实现策略的-决策逻辑>条件语句（if-else）：实现策略的 “决策逻辑”</h3><p>条件语句用于 “根据不同情况执行不同操作”，是策略的核心 —— 比如 “当股价突破 20 日均线时买入，跌破时卖出”。</p><p><strong>示例</strong>：双均线策略的买卖信号</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>ma_strategy</span>(close, short_window<span style=color:#ff79c6>=</span><span style=color:#bd93f9>5</span>, long_window<span style=color:#ff79c6>=</span><span style=color:#bd93f9>20</span>):
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    双均线策略信号：短期均线上穿长期均线买，下穿卖
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    参数：close - 收盘价列表；short_window - 短期均线窗口；long_window - 长期均线窗口
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    返回：信号列表（1=买，-1=卖，0=无信号）
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    signals <span style=color:#ff79c6>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#6272a4># 计算短期和长期均线（简化版：取最近N日均值）</span>
</span></span><span style=display:flex><span>    short_ma <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>sum</span>(close[<span style=color:#ff79c6>-</span>short_window:]) <span style=color:#ff79c6>/</span> short_window
</span></span><span style=display:flex><span>    long_ma <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>sum</span>(close[<span style=color:#ff79c6>-</span>long_window:]) <span style=color:#ff79c6>/</span> long_window
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#6272a4># 判断信号</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> short_ma <span style=color:#ff79c6>&gt;</span> long_ma:
</span></span><span style=display:flex><span>        signals<span style=color:#ff79c6>.</span>append(<span style=color:#bd93f9>1</span>)  <span style=color:#6272a4># 买</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>elif</span> short_ma <span style=color:#ff79c6>&lt;</span> long_ma:
</span></span><span style=display:flex><span>        signals<span style=color:#ff79c6>.</span>append(<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>)  <span style=color:#6272a4># 卖</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>        signals<span style=color:#ff79c6>.</span>append(<span style=color:#bd93f9>0</span>)  <span style=color:#6272a4># 无信号</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> signals
</span></span></code></pre></div><h3 id=循环语句whilefor处理批量数据的-引擎>循环语句（while/for）：处理批量数据的 “引擎”</h3><p>循环用于 “重复执行某段代码”，在量化中常用于处理批量数据 —— 比如计算多只股票的因子、遍历多年的交易日数据。</p><ul><li><strong>for 循环</strong>：适合 “已知循环次数” 的场景（如遍历列表、字典）。 示例：计算多只股票的市值</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># 多只股票的价格和股数</span>
</span></span><span style=display:flex><span>stocks <span style=color:#ff79c6>=</span> [
</span></span><span style=display:flex><span>    {<span style=color:#f1fa8c>&#34;code&#34;</span>: <span style=color:#f1fa8c>&#34;600036.SH&#34;</span>, <span style=color:#f1fa8c>&#34;price&#34;</span>: <span style=color:#bd93f9>30.5</span>, <span style=color:#f1fa8c>&#34;shares&#34;</span>: <span style=color:#bd93f9>1000000000</span>},  <span style=color:#6272a4># 10亿股</span>
</span></span><span style=display:flex><span>    {<span style=color:#f1fa8c>&#34;code&#34;</span>: <span style=color:#f1fa8c>&#34;000858.SZ&#34;</span>, <span style=color:#f1fa8c>&#34;price&#34;</span>: <span style=color:#bd93f9>50.2</span>, <span style=color:#f1fa8c>&#34;shares&#34;</span>: <span style=color:#bd93f9>500000000</span>}    <span style=color:#6272a4># 5亿股</span>
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 遍历计算市值</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> stock <span style=color:#ff79c6>in</span> stocks:
</span></span><span style=display:flex><span>    market_cap <span style=color:#ff79c6>=</span> stock[<span style=color:#f1fa8c>&#34;price&#34;</span>] <span style=color:#ff79c6>*</span> stock[<span style=color:#f1fa8c>&#34;shares&#34;</span>] <span style=color:#ff79c6>/</span> <span style=color:#bd93f9>100000000</span>  <span style=color:#6272a4># 转成亿元</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;</span><span style=color:#f1fa8c>{</span>stock[<span style=color:#f1fa8c>&#39;code&#39;</span>]<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c> 市值：</span><span style=color:#f1fa8c>{</span>market_cap<span style=color:#f1fa8c>:</span><span style=color:#f1fa8c>.2f</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>亿元&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#6272a4># 结果：</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 600036.SH 市值：305.00亿元</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 000858.SZ 市值：251.00亿元</span>
</span></span></code></pre></div><ul><li><strong>while 循环</strong>：适合 “未知循环次数，满足条件就继续” 的场景（如等待行情数据）。 示例：等待股价跌破某个阈值</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>price <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>30.5</span>  <span style=color:#6272a4># 当前股价</span>
</span></span><span style=display:flex><span>target_price <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>28.0</span>  <span style=color:#6272a4># 目标买入价</span>
</span></span><span style=display:flex><span>count <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>  <span style=color:#6272a4># 计数</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 股价未跌破目标价时，持续监控</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>while</span> price <span style=color:#ff79c6>&gt;</span> target_price:
</span></span><span style=display:flex><span>    count <span style=color:#ff79c6>+=</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;第</span><span style=color:#f1fa8c>{</span>count<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>次监控：股价</span><span style=color:#f1fa8c>{</span>price<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>元，未达目标&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#6272a4># 模拟股价波动（实际中会实时更新）</span>
</span></span><span style=display:flex><span>    price <span style=color:#ff79c6>-=</span> <span style=color:#bd93f9>0.1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;股价跌至</span><span style=color:#f1fa8c>{</span>price<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>元，可买入！&#34;</span>)
</span></span></code></pre></div><h3 id=类class封装复杂逻辑的-容器>类（class）：封装复杂逻辑的 “容器”</h3><p>类是 “属性（数据）+ 方法（函数）” 的集合，适合封装复杂的量化组件 —— 比如一个完整的因子模型（包含参数、计算方法、回测逻辑）、一个交易账户（包含持仓、资金、下单方法）。</p><p><strong>示例</strong>：定义一个 “交易账户” 类</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>TradingAccount</span>:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>__init__</span>(<span style=font-style:italic>self</span>, initial_cash<span style=color:#ff79c6>=</span><span style=color:#bd93f9>100000</span>):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;初始化账户：初始资金、空持仓&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>cash <span style=color:#ff79c6>=</span> initial_cash  <span style=color:#6272a4># 现金</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>holdings <span style=color:#ff79c6>=</span> {}  <span style=color:#6272a4># 持仓：{股票代码: 股数}</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>buy</span>(<span style=font-style:italic>self</span>, code, price, shares):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;买入股票&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        cost <span style=color:#ff79c6>=</span> price <span style=color:#ff79c6>*</span> shares
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> cost <span style=color:#ff79c6>&gt;</span> <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>cash:
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;资金不足，无法买入&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>        <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>cash <span style=color:#ff79c6>-=</span> cost
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> code <span style=color:#ff79c6>in</span> <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>holdings:
</span></span><span style=display:flex><span>            <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>holdings[code] <span style=color:#ff79c6>+=</span> shares
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>            <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>holdings[code] <span style=color:#ff79c6>=</span> shares
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;买入</span><span style=color:#f1fa8c>{</span>code<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c> </span><span style=color:#f1fa8c>{</span>shares<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>股，剩余现金：</span><span style=color:#f1fa8c>{</span><span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>cash<span style=color:#f1fa8c>:</span><span style=color:#f1fa8c>.2f</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>元&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>sell</span>(<span style=font-style:italic>self</span>, code, price, shares):
</span></span><span style=display:flex><span>        <span style=color:#f1fa8c>&#34;&#34;&#34;卖出股票&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> code <span style=color:#ff79c6>not</span> <span style=color:#ff79c6>in</span> <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>holdings <span style=color:#ff79c6>or</span> <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>holdings[code] <span style=color:#ff79c6>&lt;</span> shares:
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;持仓不足，无法卖出&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>        revenue <span style=color:#ff79c6>=</span> price <span style=color:#ff79c6>*</span> shares
</span></span><span style=display:flex><span>        <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>cash <span style=color:#ff79c6>+=</span> revenue
</span></span><span style=display:flex><span>        <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>holdings[code] <span style=color:#ff79c6>-=</span> shares
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>holdings[code] <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>del</span> <span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>holdings[code]
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>f</span><span style=color:#f1fa8c>&#34;卖出</span><span style=color:#f1fa8c>{</span>code<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c> </span><span style=color:#f1fa8c>{</span>shares<span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>股，剩余现金：</span><span style=color:#f1fa8c>{</span><span style=font-style:italic>self</span><span style=color:#ff79c6>.</span>cash<span style=color:#f1fa8c>:</span><span style=color:#f1fa8c>.2f</span><span style=color:#f1fa8c>}</span><span style=color:#f1fa8c>元&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 使用账户类</span>
</span></span><span style=display:flex><span>account <span style=color:#ff79c6>=</span> TradingAccount(initial_cash<span style=color:#ff79c6>=</span><span style=color:#bd93f9>100000</span>)
</span></span><span style=display:flex><span>account<span style=color:#ff79c6>.</span>buy(<span style=color:#f1fa8c>&#34;600036.SH&#34;</span>, <span style=color:#bd93f9>30.5</span>, <span style=color:#bd93f9>1000</span>)  <span style=color:#6272a4># 买入1000股，花费30500元</span>
</span></span><span style=display:flex><span>account<span style=color:#ff79c6>.</span>sell(<span style=color:#f1fa8c>&#34;600036.SH&#34;</span>, <span style=color:#bd93f9>32.0</span>, <span style=color:#bd93f9>500</span>)   <span style=color:#6272a4># 卖出500股，收入16000元</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 结果：剩余现金=100000-30500+16000=85500元，持仓500股</span>
</span></span></code></pre></div><p>类的优势是 “模块化”—— 将账户的资金、持仓、买卖操作封装在一起，方便管理和复用（比如同时模拟多个账户的交易）。</p><ol start=5><li><h3 id=常用算法量化中的-解题思路>常用算法：量化中的 “解题思路”</h3></li></ol><p>算法是 “解决问题的步骤”，在量化中，以下两种算法尤为重要：</p><ul><li><strong>滑动窗口算法</strong>：计算 “固定窗口内的统计量”（如 N 日均值、N 日波动率），是因子计算的核心。 示例：计算 5 日收盘价均值</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>sliding_window_mean</span>(close, window<span style=color:#ff79c6>=</span><span style=color:#bd93f9>5</span>):
</span></span><span style=display:flex><span>    means <span style=color:#ff79c6>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(window<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>, <span style=color:#8be9fd;font-style:italic>len</span>(close)):
</span></span><span style=display:flex><span>        <span style=color:#6272a4># 取当前位置前window个数据的均值</span>
</span></span><span style=display:flex><span>        mean <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>sum</span>(close[i<span style=color:#ff79c6>-</span>window<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>:i<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>]) <span style=color:#ff79c6>/</span> window
</span></span><span style=display:flex><span>        means<span style=color:#ff79c6>.</span>append(mean)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> means
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>close <span style=color:#ff79c6>=</span> [<span style=color:#bd93f9>30.5</span>, <span style=color:#bd93f9>31.2</span>, <span style=color:#bd93f9>30.8</span>, <span style=color:#bd93f9>31.5</span>, <span style=color:#bd93f9>32.0</span>, <span style=color:#bd93f9>32.5</span>, <span style=color:#bd93f9>33.0</span>]
</span></span><span style=display:flex><span>ma5 <span style=color:#ff79c6>=</span> sliding_window_mean(close)  <span style=color:#6272a4># 结果：[31.2, 31.5, 32.0, 32.6, 33.0]</span>
</span></span></code></pre></div><ul><li><strong>二分查找算法</strong>：在有序数据中快速定位目标（如在历史价格中找某一价位的出现时间），提高效率。 示例：在有序收盘价中找首次突破 32 元的日期</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>def</span> <span style=color:#50fa7b>binary_search_breakthrough</span>(close, target<span style=color:#ff79c6>=</span><span style=color:#bd93f9>32</span>):
</span></span><span style=display:flex><span>    left, right <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>, <span style=color:#8be9fd;font-style:italic>len</span>(close)<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>while</span> left <span style=color:#ff79c6>&lt;=</span> right:
</span></span><span style=display:flex><span>        mid <span style=color:#ff79c6>=</span> (left <span style=color:#ff79c6>+</span> right) <span style=color:#ff79c6>//</span> <span style=color:#bd93f9>2</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> close[mid] <span style=color:#ff79c6>&lt;</span> target:
</span></span><span style=display:flex><span>            left <span style=color:#ff79c6>=</span> mid <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span>:
</span></span><span style=display:flex><span>            right <span style=color:#ff79c6>=</span> mid <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4># left为首次突破目标的位置</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> left <span style=color:#ff79c6>if</span> left <span style=color:#ff79c6>&lt;</span> <span style=color:#8be9fd;font-style:italic>len</span>(close) <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>close <span style=color:#ff79c6>=</span> [<span style=color:#bd93f9>30.5</span>, <span style=color:#bd93f9>31.2</span>, <span style=color:#bd93f9>31.8</span>, <span style=color:#bd93f9>32.0</span>, <span style=color:#bd93f9>32.5</span>]  <span style=color:#6272a4># 有序（递增）</span>
</span></span><span style=display:flex><span>index <span style=color:#ff79c6>=</span> binary_search_breakthrough(close, <span style=color:#bd93f9>32</span>)  <span style=color:#6272a4># 结果：3（第4个元素，索引3）</span>
</span></span></code></pre></div><h2 id=四numpy>四、Numpy</h2><p>当数据量增大（比如处理全市场股票的分钟级数据），Python 基础数据结构（如列表）的运算速度会变得很慢。而 Numpy（Numerical Python）通过 “多维数组” 和 “向量化操作”，将计算效率提升 10-100 倍，是量化数据处理的 “核心引擎”。</p><p><strong>多维数组（ndarray）</strong> ：Numpy 的核心数据结构，可表示向量（1 维）、矩阵（2 维）、张量（高维），适合存储金融数据（如多只股票的多日收盘价）。 示例：用二维数组存储 3 只股票 5 天的收盘价</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> numpy <span style=color:#ff79c6>as</span> np
</span></span><span style=display:flex><span><span style=color:#6272a4># 3只股票，5天收盘价（行=股票，列=日期）</span>
</span></span><span style=display:flex><span>close_array <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>array([
</span></span><span style=display:flex><span>    [<span style=color:#bd93f9>30.5</span>, <span style=color:#bd93f9>31.2</span>, <span style=color:#bd93f9>30.8</span>, <span style=color:#bd93f9>31.5</span>, <span style=color:#bd93f9>32.0</span>],  <span style=color:#6272a4># 股票1</span>
</span></span><span style=display:flex><span>    [<span style=color:#bd93f9>50.2</span>, <span style=color:#bd93f9>50.5</span>, <span style=color:#bd93f9>51.0</span>, <span style=color:#bd93f9>50.8</span>, <span style=color:#bd93f9>51.5</span>],  <span style=color:#6272a4># 股票2</span>
</span></span><span style=display:flex><span>    [<span style=color:#bd93f9>20.1</span>, <span style=color:#bd93f9>19.8</span>, <span style=color:#bd93f9>20.0</span>, <span style=color:#bd93f9>20.5</span>, <span style=color:#bd93f9>21.0</span>]   <span style=color:#6272a4># 股票3</span>
</span></span><span style=display:flex><span>])
</span></span></code></pre></div><p><strong>数学函数</strong>：内置大量高效数学函数（如均值、标准差、矩阵运算），无需手动写循环。 示例：计算每只股票的 5 日平均收盘价</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># 按行计算均值（axis=1表示行，axis=0表示列）</span>
</span></span><span style=display:flex><span>stock_means <span style=color:#ff79c6>=</span> np<span style=color:#ff79c6>.</span>mean(close_array, axis<span style=color:#ff79c6>=</span><span style=color:#bd93f9>1</span>)  
</span></span><span style=display:flex><span><span style=color:#6272a4># 结果：[31.2, 50.8, 20.28]</span>
</span></span></code></pre></div><p><strong>索引和切片</strong>：快速提取子集，比列表更灵活。 示例：取股票 1 的后 3 天收盘价</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>stock1_last3 <span style=color:#ff79c6>=</span> close_array[<span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>2</span>:]  <span style=color:#6272a4># 第0行（股票1），第2列及以后（后3天）</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 结果：[30.8, 31.5, 32.0]</span>
</span></span></code></pre></div><p><strong>向量化操作</strong>：无需循环，直接对整个数组运算，速度极快。 示例：计算所有股票的日收益率（相比列表循环，效率提升 10 倍以上）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># 向量化计算：(今日 - 昨日)/昨日（除第一列外）</span>
</span></span><span style=display:flex><span>returns <span style=color:#ff79c6>=</span> (close_array[:, <span style=color:#bd93f9>1</span>:] <span style=color:#ff79c6>-</span> close_array[:, :<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>]) <span style=color:#ff79c6>/</span> close_array[:, :<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>]  
</span></span><span style=display:flex><span><span style=color:#6272a4># 结果为3行4列的数组（3只股票，4天收益率）</span>
</span></span></code></pre></div><p><strong>高性能</strong>：底层用 C 语言实现，处理百万级数据时，速度远超纯 Python 代码（比如计算 1000 只股票的年收益率，Numpy 只需 0.1 秒，列表循环可能需要 10 秒）。</p><h2 id=五pandas>五、Pandas</h2><p>如果说 Numpy 是 “数值计算引擎”，Pandas 就是 “金融数据处理的瑞士军刀”—— 它基于 Numpy 构建，提供了更直观的数据结构（Series 和 DataFrame），完美适配股票、基金等时间序列数据的处理。</p><p><strong>Series（一维标记数组）</strong> ：带 “索引” 的一维数组，适合记录 “单变量的时间序列”（如一只股票的每日收盘价、一个因子的每日值）。 示例：某股票的收盘价序列</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#ff79c6>import</span> pandas <span style=color:#ff79c6>as</span> pd
</span></span><span style=display:flex><span><span style=color:#6272a4># 索引为日期，值为收盘价</span>
</span></span><span style=display:flex><span>close_series <span style=color:#ff79c6>=</span> pd<span style=color:#ff79c6>.</span>Series(
</span></span><span style=display:flex><span>    [<span style=color:#bd93f9>30.5</span>, <span style=color:#bd93f9>31.2</span>, <span style=color:#bd93f9>30.8</span>, <span style=color:#bd93f9>31.5</span>, <span style=color:#bd93f9>32.0</span>],
</span></span><span style=display:flex><span>    index<span style=color:#ff79c6>=</span>pd<span style=color:#ff79c6>.</span>date_range(<span style=color:#f1fa8c>&#34;2023-10-01&#34;</span>, periods<span style=color:#ff79c6>=</span><span style=color:#bd93f9>5</span>)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#6272a4># 结果：</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 2023-10-01    30.5</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 2023-10-02    31.2</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 2023-10-03    30.8</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 2023-10-04    31.5</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 2023-10-05    32.0</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># dtype: float64</span>
</span></span></code></pre></div><p>Series 的优势是 “索引对齐”—— 比如计算收益率时，自动按日期匹配，无需手动对齐时间。</p><p><strong>DataFrame（二维表格数据）</strong> ：带 “行索引 + 列名” 的二维表格，适合记录 “多变量的时间序列”（如多只股票的收盘价、一只股票的多因子值）。 示例：3 只股票的 5 日收盘价表格</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#6272a4># 行索引=日期，列名=股票代码，值=收盘价</span>
</span></span><span style=display:flex><span>close_df <span style=color:#ff79c6>=</span> pd<span style=color:#ff79c6>.</span>DataFrame(
</span></span><span style=display:flex><span>    [
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>30.5</span>, <span style=color:#bd93f9>50.2</span>, <span style=color:#bd93f9>20.1</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>31.2</span>, <span style=color:#bd93f9>50.5</span>, <span style=color:#bd93f9>19.8</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>30.8</span>, <span style=color:#bd93f9>51.0</span>, <span style=color:#bd93f9>20.0</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>31.5</span>, <span style=color:#bd93f9>50.8</span>, <span style=color:#bd93f9>20.5</span>],
</span></span><span style=display:flex><span>        [<span style=color:#bd93f9>32.0</span>, <span style=color:#bd93f9>51.5</span>, <span style=color:#bd93f9>21.0</span>]
</span></span><span style=display:flex><span>    ],
</span></span><span style=display:flex><span>    index<span style=color:#ff79c6>=</span>pd<span style=color:#ff79c6>.</span>date_range(<span style=color:#f1fa8c>&#34;2023-10-01&#34;</span>, periods<span style=color:#ff79c6>=</span><span style=color:#bd93f9>5</span>),
</span></span><span style=display:flex><span>    columns<span style=color:#ff79c6>=</span>[<span style=color:#f1fa8c>&#34;600036.SH&#34;</span>, <span style=color:#f1fa8c>&#34;000858.SZ&#34;</span>, <span style=color:#f1fa8c>&#34;601318.SH&#34;</span>]
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>DataFrame 的核心功能：</p><ul><li>快速筛选：<code>close_df["600036.SH"]</code>取单只股票数据；</li><li>按行 / 列运算：<code>close_df.mean(axis=1)</code>计算每日平均收盘价；</li><li>缺失值处理：<code>close_df.fillna(method="ffill")</code>用前值填充缺失的股价；</li><li>合并数据：<code>pd.merge(df1, df2, on="date")</code>按日期合并因子和价格数据。</li></ul><h3 id=pandas-在量化中的高频用法>Pandas 在量化中的高频用法</h3><ul><li>读取金融数据：<code>pd.read_csv("stock_data.csv")</code>读取本地数据，<code>pd.read_excel("fund_data.xlsx")</code>读取 Excel 数据；</li><li>时间序列处理：<code>close_df.resample("W").mean()</code>将日数据转为周数据（周均值）；</li><li>因子计算：<code>close_df.pct_change(5)</code>计算 5 日收益率（一行代码替代滑动窗口循环）；</li><li>策略回测：结合条件语句，快速生成买卖信号（如<code>close_df["signal"] = np.where(close_df["600036.SH"] > 32, 1, 0)</code>）。</li></ul><h2 id=六提示>六、提示</h2><p>对新手来说，学习的关键是 “边学边练”：先用列表、字典处理小批量数据，再用 Numpy 提升计算效率，最后用 Pandas 处理真实的金融数据（如从 Tushare、聚宽等平台获取股票数据，尝试计算一个简单的动量因子）。</p><hr><ul class=pager><li class=previous><a href=/2021/05/13/reflections-on-witnessing-imbalance/ data-toggle=tooltip data-placement=top title=《见证失衡》读后感>&larr;
Previous Post</a></li><li class=next><a href=/post/6-tech/hugo-theme-clean-white/ data-toggle=tooltip data-placement=top title="Hugo Theme: CleanWhite">Next
Post &rarr;</a></li></ul><script src=https://giscus.app/client.js data-repo=XiangdiWu/XiangdiWu.github.io data-repo-id=R_kgDOP0pDUQ data-category=Announcements data-category-id=DIC_kwDOP0pDUc4CvwjG data-mapping=pathname data-reactions-enabled=1 data-emit-metadata=0 data-theme=light data-lang=zh-CN crossorigin=anonymous async></script></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/deep-learning title="deep learning">deep learning
</a><a href=/tags/machine-learning title="machine learning">machine learning
</a><a href=/tags/math title=math>math
</a><a href=/tags/model title=model>model
</a><a href=/tags/nlp title=nlp>nlp
</a><a href=/tags/quant title=quant>quant</a></div></section><section><hr><h5>FRIENDS</h5><ul class=list-inline><li><a target=_blank href=https://www.factorwar.com/data/factor-models/>GetAstockFactors</a></li><li><a target=_blank href=https://datawhalechina.github.io/whale-quant/#/>Whale-Quant</a></li></ul></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a href=mailto:bernicewu2000@outlook.com><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-envelope fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=/img/wechat_qrcode.jpg><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-weixin fa-stack-1x fa-inverse"></i></span></a></li><li><a target=_blank href=https://github.com/xiangdiwu><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="Xiangdi Blog"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; Xiangdi Blog 2025</p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){n=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),t=$(this).text(),i=$('<a href="'+o+'" rel="nofollow" title="'+t+'">'+t+"</a>"),s=$('<li class="'+n+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script><style>.markmap>svg{width:100%;height:300px}</style><script>window.markmap={autoLoader:{manual:!0,onReady(){const{autoLoader:e,builtInPlugins:t}=window.markmap;e.transformPlugins=t.filter(e=>e.name!=="prism")}}}</script><script src=https://cdn.jsdelivr.net/npm/markmap-autoloader></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css integrity="sha512-r2+FkHzf1u0+SQbZOoIz2RxWOIWfdEzRuYybGjzKq18jG9zaSfEy9s3+jMqG/zPtRor/q4qaUCYQpmSjTw8M+g==" crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js integrity="sha512-INps9zQ2GUEMCQD7xiZQbGUVnqnzEvlynVy6eqcTcHN4+aQiLo9/uaQqckDpdJ8Zm3M0QBs+Pktg4pz0kEklUg==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/mhchem.min.js integrity="sha512-mxjNw/u1lIsFC09k/unscDRY3ofIYPVFbWkP8slrePcS36ht4d/OZ8rRu5yddB2uiqajhTcLD8+jupOWuYPebg==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js integrity="sha512-YJVxTjqttjsU3cSvaTRqsSl0wbRgZUNF+NGGCgto/MUbIvaLdXQzGTCQu4CvyJZbZctgflVB0PXw9LLmTWm5/w==" crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"},{display:!0,left:"\\[",right:"\\]"}],errorcolor:"#CD5C5C",throwonerror:!1})'></script></body></html>